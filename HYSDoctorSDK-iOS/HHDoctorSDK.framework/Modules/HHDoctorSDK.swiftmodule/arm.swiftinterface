// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.1 (swiftlang-1100.0.270.13 clang-1100.0.33.7)
// swift-module-flags: -target armv7-apple-ios9.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name HHDoctorSDK
import AVFoundation
import AVKit
import AdSupport
import CoreGraphics
import CoreLocation
import CoreTelephony
import Darwin
import Dispatch
import Foundation
@_exported import HHDoctorSDK
import ImageIO
import LocalAuthentication
import MobileCoreServices
import NIMAVChat
import NIMSDK
import ObjectiveC
import Photos
import Security
import SecurityKit
import Swift
import SystemConfiguration
import UIKit
import WebKit
public protocol AEAD {
  static var kLen: Swift.Int { get }
  static var ivRange: Swift.Range<Swift.Int> { get }
}
final public class AEADChaCha20Poly1305 : HHDoctorSDK.AEAD {
  public static let kLen: Swift.Int
  public static var ivRange: Swift.Range<Swift.Int>
  public static func encrypt(_ plainText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>) throws -> (cipherText: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>)
  public static func decrypt(_ cipherText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>) throws -> (plainText: Swift.Array<Swift.UInt8>, success: Swift.Bool)
  @objc deinit
}
extension AES {
  convenience public init(key: Swift.String, iv: Swift.String, padding: HHDoctorSDK.Padding = .pkcs7) throws
}
extension AES : HHDoctorSDK.Cryptors {
  final public func makeEncryptor() throws -> HHDoctorSDK.AES.Encryptor
  final public func makeDecryptor() throws -> HHDoctorSDK.AES.Decryptor
  public typealias EncryptorType = HHDoctorSDK.AES.Encryptor
  public typealias DecryptorType = HHDoctorSDK.AES.Decryptor
}
extension AES {
  public struct Encryptor : HHDoctorSDK.Updatable {
    mutating public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  }
}
extension AES {
  public struct Decryptor : HHDoctorSDK.RandomAccessCryptor {
    mutating public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
    @discardableResult
    mutating public func seek(to position: Swift.Int) -> Swift.Bool
  }
}
final public class AES {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidData
    public static func == (a: HHDoctorSDK.AES.Error, b: HHDoctorSDK.AES.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum Variant : Swift.Int {
    case aes128, aes192, aes256
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  final public var variant: HHDoctorSDK.AES.Variant {
    get
  }
  public init(key: Swift.Array<Swift.UInt8>, blockMode: HHDoctorSDK.BlockMode, padding: HHDoctorSDK.Padding = .pkcs7) throws
  @objc deinit
}
extension AES : HHDoctorSDK.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension Array {
  public init(reserveCapacity: Swift.Int)
}
extension Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Array where Element == Swift.UInt8 {
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
  public func md5() -> [Element]
  public func sha1() -> [Element]
  public func sha224() -> [Element]
  public func sha256() -> [Element]
  public func sha384() -> [Element]
  public func sha512() -> [Element]
  public func sha2(_ variant: HHDoctorSDK.SHA2.Variant) -> [Element]
  public func sha3(_ variant: HHDoctorSDK.SHA3.Variant) -> [Element]
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.UInt16
  public func encrypt(cipher: HHDoctorSDK.Cipher) throws -> [Element]
  public func decrypt(cipher: HHDoctorSDK.Cipher) throws -> [Element]
  public func authenticate<A>(with authenticator: A) throws -> [Element] where A : HHDoctorSDK.Authenticator
}
extension Array where Element == Swift.UInt8 {
  public func toBase64() -> Swift.String?
  public init(base64: Swift.String)
}
public protocol Authenticator {
  func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public enum Bit : Swift.Int {
  case zero
  case one
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public enum BlockMode {
  case ECB, CBC(iv: Swift.Array<Swift.UInt8>), PCBC(iv: Swift.Array<Swift.UInt8>), CFB(iv: Swift.Array<Swift.UInt8>), OFB(iv: Swift.Array<Swift.UInt8>), CTR(iv: Swift.Array<Swift.UInt8>)
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    public static func == (a: HHDoctorSDK.BlockMode.Error, b: HHDoctorSDK.BlockMode.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
extension Blowfish {
  convenience public init(key: Swift.String, iv: Swift.String, padding: HHDoctorSDK.Padding = .pkcs7) throws
}
final public class Blowfish {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    public static func == (a: HHDoctorSDK.Blowfish.Error, b: HHDoctorSDK.Blowfish.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, blockMode: HHDoctorSDK.BlockMode = .CBC(iv: Array<UInt8>(repeating: 0, count: Blowfish.blockSize)), padding: HHDoctorSDK.Padding) throws
  @objc deinit
}
extension Blowfish : HHDoctorSDK.Cipher {
  final public func encrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
  final public func decrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
}
public class BusyPics {
  public static let `default`: HHDoctorSDK.BusyPics
  public func cacheImgs()
  public func getImgs() -> [Foundation.URL?]
  @objc deinit
}
public struct CallDoctorModel : HHDoctorSDK.Mappable {
  public var doctor: HHDoctorSDK.HHDoctorModel?
  public var order: HHDoctorSDK.OrderModel?
  public var appoint: Swift.String?
  public var pushFlowUrl: Swift.String?
  public var realPatientUuid: Swift.Int?
  public init?(map: HHDoctorSDK.Map)
  mutating public func mapping(map: HHDoctorSDK.Map)
}
extension ChaCha20 {
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
final public class ChaCha20 {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: HHDoctorSDK.ChaCha20.Error, b: HHDoctorSDK.ChaCha20.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension ChaCha20 : HHDoctorSDK.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension ChaCha20 {
  public struct Encryptor : HHDoctorSDK.Updatable {
    mutating public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  }
}
extension ChaCha20 {
  public struct Decryptor : HHDoctorSDK.Updatable {
    mutating public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = true) throws -> Swift.Array<Swift.UInt8>
  }
}
extension ChaCha20 : HHDoctorSDK.Cryptors {
  final public func makeEncryptor() -> HHDoctorSDK.ChaCha20.Encryptor
  final public func makeDecryptor() -> HHDoctorSDK.ChaCha20.Decryptor
  public typealias EncryptorType = HHDoctorSDK.ChaCha20.Encryptor
  public typealias DecryptorType = HHDoctorSDK.ChaCha20.Decryptor
}
final public class Checksum {
  @objc deinit
}
extension Checksum {
  public static func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public static func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16
}
public enum CipherError : Swift.Error {
  case encrypt
  case decrypt
  public static func == (a: HHDoctorSDK.CipherError, b: HHDoctorSDK.CipherError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol Cipher : AnyObject {
  var keySize: Swift.Int { get }
  func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension Cipher {
  public func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
final public class CMAC : HHDoctorSDK.Authenticator {
  public enum Error : Swift.Error {
    case wrongKeyLength
    public static func == (a: HHDoctorSDK.CMAC.Error, b: HHDoctorSDK.CMAC.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init(key: Swift.Array<Swift.UInt8>) throws
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
@objc public class CommentBaseVC : UIKit.UIViewController {
  @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc public class CommentVC : HHDoctorSDK.CommentBaseVC {
  @objc override dynamic public func viewDidLoad()
  public static func show(_ orderId: Swift.String, docId: Swift.String, uuid: Swift.Int?, type: HHDoctorSDK.HHCallType?, _ model: HHDoctorSDK.HHGetQuesetionModel?)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension String {
  public func subTo(_ index: Swift.Int) -> Swift.String
}
public func hh_downloadImg(_ url: Foundation.URL?, finish: @escaping ((UIKit.UIImage?, Foundation.Data?, Swift.Error?) -> Swift.Void))
public protocol Cryptors : AnyObject {
  associatedtype EncryptorType : HHDoctorSDK.Updatable
  associatedtype DecryptorType : HHDoctorSDK.Updatable
  func makeEncryptor() throws -> Self.EncryptorType
  func makeDecryptor() throws -> Self.DecryptorType
  static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension Cryptors {
  public static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
open class CustomDateFormatTransform : HHDoctorSDK.DateFormatterTransform {
  public init(formatString: Swift.String)
  override public init(dateFormatter: Foundation.DateFormatter)
  @objc deinit
}
extension Data {
  public func checksum() -> Swift.UInt16
  public func md5() -> Foundation.Data
  public func sha1() -> Foundation.Data
  public func sha224() -> Foundation.Data
  public func sha256() -> Foundation.Data
  public func sha384() -> Foundation.Data
  public func sha512() -> Foundation.Data
  public func sha3(_ variant: HHDoctorSDK.SHA3.Variant) -> Foundation.Data
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc16(seed: Swift.UInt16? = nil) -> Foundation.Data
  public func encrypt(cipher: HHDoctorSDK.Cipher) throws -> Foundation.Data
  public func decrypt(cipher: HHDoctorSDK.Cipher) throws -> Foundation.Data
  public func authenticate(with authenticator: HHDoctorSDK.Authenticator) throws -> Foundation.Data
}
extension Data {
  public init(hex: Swift.String)
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func toHexString() -> Swift.String
}
open class DataTransform : HHDoctorSDK.TransformType {
  public typealias Object = Foundation.Data
  public typealias JSON = Swift.String
  public init()
  open func transformFromJSON(_ value: Any?) -> Foundation.Data?
  open func transformToJSON(_ value: Foundation.Data?) -> Swift.String?
  @objc deinit
}
open class DateFormatterTransform : HHDoctorSDK.TransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.String
  final public let dateFormatter: Foundation.DateFormatter
  public init(dateFormatter: Foundation.DateFormatter)
  open func transformFromJSON(_ value: Any?) -> Foundation.Date?
  open func transformToJSON(_ value: Foundation.Date?) -> Swift.String?
  @objc deinit
}
open class DateTransform : HHDoctorSDK.TransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.Double
  public init()
  open func transformFromJSON(_ value: Any?) -> Foundation.Date?
  open func transformToJSON(_ value: Foundation.Date?) -> Swift.Double?
  @objc deinit
}
public struct DGElasticPullToRefreshConstants {
  public static var WaveMaxHeight: CoreGraphics.CGFloat
  public static var MinOffsetToPull: CoreGraphics.CGFloat
  public static var LoadingContentInset: CoreGraphics.CGFloat
  public static var LoadingViewSize: CoreGraphics.CGFloat
}
extension NSObject {
  public func dg_addObserver(_ observer: ObjectiveC.NSObject, forKeyPath keyPath: Swift.String)
  public func dg_removeObserver(_ observer: ObjectiveC.NSObject, forKeyPath keyPath: Swift.String)
}
extension UIScrollView {
  public func dg_addPullToRefreshWithActionHandler(_ actionHandler: @escaping () -> Swift.Void, loadingView: HHDoctorSDK.DGElasticPullToRefreshLoadingView?)
  public func dg_removePullToRefresh()
  public func dg_setPullToRefreshBackgroundColor(_ color: UIKit.UIColor)
  public func dg_setPullToRefreshFillColor(_ color: UIKit.UIColor)
  public func dg_stopLoading()
  public func dg_startLoading()
}
extension UIView {
  public func dg_center(_ usePresentationLayerIfPossible: Swift.Bool) -> CoreGraphics.CGPoint
}
extension UIPanGestureRecognizer {
  public func dg_resign()
}
extension UIGestureRecognizer.State {
  public func dg_isAnyOf(_ values: [UIKit.UIGestureRecognizer.State]) -> Swift.Bool
}
@objc open class DGElasticPullToRefreshLoadingView : UIKit.UIView {
  @objc dynamic public init()
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  open func setPullProgress(_ progress: CoreGraphics.CGFloat)
  open func startAnimating()
  open func stopLoading()
  @objc deinit
}
extension CGFloat {
  public func toRadians() -> CoreGraphics.CGFloat
  public func toDegrees() -> CoreGraphics.CGFloat
}
@objc open class DGElasticPullToRefreshLoadingViewCircle : HHDoctorSDK.DGElasticPullToRefreshLoadingView {
  @objc override dynamic public init()
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  override open func setPullProgress(_ progress: CoreGraphics.CGFloat)
  override open func startAnimating()
  override open func stopLoading()
  @objc override dynamic open func tintColorDidChange()
  @objc override dynamic open func layoutSubviews()
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public enum DGElasticPullToRefreshState : Swift.Int {
  case stopped
  case dragging
  case animatingBounce
  case loading
  case animatingToStopped
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc open class DGElasticPullToRefreshView : UIKit.UIView {
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
  @objc override dynamic open func observeValue(forKeyPath keyPath: Swift.String?, of object: Any?, change: [Foundation.NSKeyValueChangeKey : Any]?, context: Swift.UnsafeMutableRawPointer?)
  @objc override dynamic open func layoutSubviews()
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
public struct DictionaryTransform<Key, Value> : HHDoctorSDK.TransformType where Key : Swift.Hashable, Key : Swift.RawRepresentable, Value : HHDoctorSDK.Mappable, Key.RawValue == Swift.String {
  public init()
  public func transformFromJSON(_ value: Any?) -> [Key : Value]?
  public func transformToJSON(_ value: [Key : Value]?) -> Any?
  public typealias Object = Swift.Dictionary<Key, Value>
  public typealias JSON = Any
}
public typealias Hash = HHDoctorSDK.Digest
public struct Digest {
  public static func md5(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha1(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha224(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha256(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha384(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha512(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha2(_ bytes: Swift.Array<Swift.UInt8>, variant: HHDoctorSDK.SHA2.Variant) -> Swift.Array<Swift.UInt8>
  public static func sha3(_ bytes: Swift.Array<Swift.UInt8>, variant: HHDoctorSDK.SHA3.Variant) -> Swift.Array<Swift.UInt8>
}
public func <- <T>(left: inout T, right: HHDoctorSDK.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: T, right: HHDoctorSDK.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout T?, right: HHDoctorSDK.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: T?, right: HHDoctorSDK.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout [T], right: HHDoctorSDK.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: [T], right: HHDoctorSDK.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout [T]?, right: HHDoctorSDK.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: [T]?, right: HHDoctorSDK.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout [Swift.String : T], right: HHDoctorSDK.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: [Swift.String : T], right: HHDoctorSDK.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout [Swift.String : T]?, right: HHDoctorSDK.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: [Swift.String : T]?, right: HHDoctorSDK.Map) where T : Swift.RawRepresentable
open class EnumTransform<T> : HHDoctorSDK.TransformType where T : Swift.RawRepresentable {
  public typealias Object = T
  public typealias JSON = T.RawValue
  public init()
  open func transformFromJSON(_ value: Any?) -> T?
  open func transformToJSON(_ value: T?) -> T.RawValue?
  @objc deinit
}
public struct HHInviteDocModel : HHDoctorSDK.Mappable {
  public var orderId: Swift.String?
  public var channelId: Swift.UInt64?
  public var doctorId: Swift.String?
  public var imageUrl: Swift.String?
  public var signalingType: Swift.String?
  public var width: CoreGraphics.CGFloat
  public var height: CoreGraphics.CGFloat
  public init?(map: HHDoctorSDK.Map)
  public init(_ info: HHDoctorSDK.HHNetCallChatInfo, meetId: Swift.UInt64?)
  public func isWhiteBoard() -> Swift.Bool
  public func isMultyCall() -> Swift.Bool
  mutating public func mapping(map: HHDoctorSDK.Map)
}
open class HexColorTransform : HHDoctorSDK.TransformType {
  public typealias Object = UIKit.UIColor
  public typealias JSON = Swift.String
  public init(prefixToJSON: Swift.Bool = false, alphaToJSON: Swift.Bool = false)
  open func transformFromJSON(_ value: Any?) -> HHDoctorSDK.HexColorTransform.Object?
  open func transformToJSON(_ value: HHDoctorSDK.HexColorTransform.Object?) -> HHDoctorSDK.HexColorTransform.JSON?
  @objc deinit
}
@objc public class HHCallerInfo : ObjectiveC.NSObject, HHDoctorSDK.Mappable {
  public var name: Swift.String?
  public var photourl: Swift.String?
  public var uuid: Swift.Int?
  public var userToken: Swift.String?
  @objc override dynamic public init()
  required public init?(map: HHDoctorSDK.Map)
  public func mapping(map: HHDoctorSDK.Map)
  @objc deinit
}
public class HHCameraConfig {
  weak public var sender: UIKit.UIViewController!
  public var mediaType: HHDoctorSDK.HHMediaType
  public var isGrayCam: Swift.Bool
  public var canReduce: Swift.Bool
  public var autoUpload: Swift.Bool
  public var maxCount: Swift.Int?
  public var crop: HHDoctorSDK.onCropFinish?
  public var canceled: HHDoctorSDK.onCanceled?
  public init()
  public func build(_ block: (inout HHDoctorSDK.HHCameraConfig) -> Swift.Void) -> HHDoctorSDK.HHCameraConfig
  @objc deinit
}
public typealias HHFetchBlock = (UIKit.UIImage?, [Swift.AnyHashable : Any]?) -> Swift.Void
public typealias onCanceled = (() -> Swift.Void)
public typealias onCapFinished = (([HHDoctorSDK.SDKCameraImageModel]?) -> Swift.Void)
public typealias onCropFinish = (UIKit.UIImage, Swift.String?) -> Swift.Void
public enum HHMediaType : Swift.Int {
  case cusCamera
  case sysCamera
  case cusVideo
  case sysVideo
  case photoImage
  case photoVideo
  case cusPhoto
  case sysCrop
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
open class HHDataController<T> where T : HHDoctorSDK.Mappable {
  open var mData: T?
  public init()
  open func request(config: HHDoctorSDK.HHRequestConfig, data: HHDoctorSDK.HHRequestData? = nil, result: HHDoctorSDK.NetResult?)
  open func emptyRequest(config: HHDoctorSDK.HHRequestConfig, data: HHDoctorSDK.HHRequestData? = nil, result: HHDoctorSDK.NetResult?)
  open func noDataRequest(config: HHDoctorSDK.HHRequestConfig, data: HHDoctorSDK.HHRequestData? = nil, result: HHDoctorSDK.NetResult?)
  @objc deinit
}
extension HHDataController {
  open func request<E>(config: HHDoctorSDK.HHRequestConfig, data: HHDoctorSDK.HHRequestData? = nil, result: ((E) -> Swift.Void)?, fail: HHDoctorSDK.HHNetError? = nil) where E : HHDoctorSDK.Mappable
}
public enum DateFormat : Swift.String {
  case Full
  case SingleDate
  case Single
  case WithoutSecond
  case WithoutYearAndSecond
  case HourMinute
  case CN_Month_Day
  case CN_Hour_Minute
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
@objc public class HHDateUtils : ObjectiveC.NSObject {
  public class func getDateForChinaStr() -> Swift.String
  public static func stringWithDurationFromSeconds(_ seconds: Foundation.TimeInterval) -> Swift.String
  public static func component(_ date: Foundation.Date) -> Foundation.DateComponents
  @objc override dynamic public init()
  @objc deinit
}
extension HHDateUtils {
  public class func date2String(_ date: Foundation.Date, format: Swift.String) -> Swift.String
  public class func date2String(_ date: Foundation.Date, format: HHDoctorSDK.DateFormat) -> Swift.String
}
extension HHDateUtils {
  public class func string2Date(_ str: Swift.String, format: HHDoctorSDK.DateFormat) -> Foundation.Date?
  public class func string2Date(_ str: Swift.String, format: Swift.String) -> Foundation.Date?
}
extension HHDateUtils {
  public static func dateStringFromNow(_ date: Swift.Int) -> Swift.String
  public static func dateStringFromInt(_ date: Swift.Int) -> Swift.String
  public static func dateYearStringFromInt(_ date: Swift.Int) -> Swift.String
}
@objc open class HHDeviceManager : ObjectiveC.NSObject {
  public static func jailBrokend() -> Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
public struct HHDoctorInfo : HHDoctorSDK.Mappable {
  public var doctorid: Swift.String?
  public var expertid: Swift.String?
  public var name: Swift.String?
  public var deptid: Swift.Int?
  public var department: Swift.String?
  public var sex: Swift.String?
  public var expertstatus: Swift.Int?
  public var photourl: Swift.String?
  public var speciality: Swift.String?
  public var introduction: Swift.String?
  public var titleid: Swift.Int?
  public var title: Swift.String?
  public var hospitalid: Swift.String?
  public var hospital: Swift.String?
  public var expertPrice: Swift.Float?
  public var standardDeptId: Swift.Int?
  public var standardid: Swift.Int?
  public var type: Swift.String?
  public var videourl: Swift.String?
  public var nurseid: Swift.String?
  public var ishospitalvisible: Swift.Int?
  public var license: Swift.String?
  public var license1: Swift.String?
  public var cardurl2: Swift.String?
  public var superLicense: Swift.String?
  public var price: Swift.Float?
  public var discountprice: Swift.Float?
  public var feidaoprice: Swift.Float?
  public var feidaoDiscountPrice: Swift.Float?
  public var videoprice: Swift.Float?
  public var videoDiscountPrice: Swift.Float?
  public var shuzhongbingliprice: Swift.Float?
  public var shuzhongbinglidiscountprice: Swift.Float?
  public var activityNumber: Swift.Int
  public var expertStatusDesc: Swift.String?
  public var expertStatusTips: Swift.String?
  public var specialIcon: Swift.String?
  public var properties: [Swift.String]?
  public var signature: Swift.String?
  public var isExpert: Swift.Int
  public var istest: Swift.Int
  public var uuid: Swift.Int
  public var beforePay: Swift.Bool
  public var providetype: Swift.String?
  public var replyaverage: Swift.String?
  public var replylike: Swift.String?
  public var replyCaseArray: [Swift.String]?
  public var MDTBrief: Swift.String?
  public var MDTPhoto: Swift.String?
  public var MDTDescn: Swift.String?
  public var MDTId: Swift.String?
  public var todayreply: Swift.String?
  public var diseaseList: [Swift.String]?
  public var expertListPhoto: Swift.String! {
    get
  }
  public var photoURLForSquare: Swift.String! {
    get
  }
  public init?(map: HHDoctorSDK.Map)
  mutating public func mapping(map: HHDoctorSDK.Map)
}
public typealias HHPriceInfo = (priceAttri: Foundation.NSMutableAttributedString, disPriceWidth: CoreGraphics.CGFloat?)
public struct HHDoctorModel : HHDoctorSDK.Mappable {
  public init?(map: HHDoctorSDK.Map)
  public var agentUuid: Swift.String?
  public var createtime: Swift.String?
  public var department: Swift.String?
  public var deptid: Swift.Int?
  public var disease: Swift.String?
  public var diseaseList: [Swift.String]?
  public var doctorid: Swift.String?
  public var expertStatus: Swift.String?
  public var expertVideoTime: Swift.String?
  public var famExpertVideoPrice: Swift.Float?
  public var famServices: Swift.Int?
  public var famprovidetypes: Swift.String?
  public var hhTitle: Swift.String?
  public var hospital: Swift.String?
  public var hospitalid: Swift.Int?
  public var introduction: Swift.String?
  public var isTest: Swift.String?
  public var login: HHDoctorSDK.LoginModel?
  public var workyear: Swift.Int?
  public var name: Swift.String?
  public var photourl: Swift.String?
  public var price: Swift.Float?
  public var providetype: Swift.String?
  public var province: Swift.String?
  public var service: Swift.String?
  public var serviceTypeStatus: Swift.String?
  public var speciality: Swift.String?
  public var standardDeptid: Swift.Int?
  public var standardDeptname: Swift.String?
  public var standardid: Swift.Int?
  public var subdept: Swift.String?
  public var subdeptids: Swift.String?
  public var title: Swift.String?
  public var titleid: Swift.Int?
  public var vedioTimeList: Swift.String?
  public var videoprice: Swift.Float?
  public var license: Swift.String?
  public init()
  mutating public func mapping(map: HHDoctorSDK.Map)
  public func isJianzhi() -> Swift.Bool
  public func supportType(type: HHDoctorSDK.HHConsType) -> Swift.Bool
  public func getPrice() -> HHDoctorSDK.HHPriceInfo?
  public func isZhuanke() -> Swift.Bool
}
public struct LoginModel : HHDoctorSDK.Mappable {
  public var actionSource: Swift.String?
  public var loginname: Swift.String?
  public var name: Swift.String?
  public var photourl: Swift.String?
  public var uuid: Swift.Int?
  public var videoToken: Swift.String?
  public var phoneno: Swift.String?
  public init?(map: HHDoctorSDK.Map)
  mutating public func mapping(map: HHDoctorSDK.Map)
}
public enum HHConsType : Swift.String {
  case normal
  case expert_video
  case feiDao
  case video
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct HHEmptyModel : HHDoctorSDK.Mappable {
  public init()
  public init?(map: HHDoctorSDK.Map)
  mutating public func mapping(map: HHDoctorSDK.Map)
}
public class HHEncryptUtils {
  public static func encrypto(key: Swift.String, content: Swift.String) -> Swift.String?
  public static func decrypto(key: Swift.String, content: Swift.String) -> Swift.String?
  public static func encrypto(key: Swift.String, content: Foundation.Data) -> Foundation.Data?
  public static func decrypto(key: Swift.String, content: Foundation.Data) -> Foundation.Data?
  @objc deinit
}
@objc public class HHFileCacheManager : ObjectiveC.NSObject {
  public enum HHAssetPathType {
    case image
    case video
    case sound
    case dicom
    case fb
    case other
    case dataBase
    public static func == (a: HHDoctorSDK.HHFileCacheManager.HHAssetPathType, b: HHDoctorSDK.HHFileCacheManager.HHAssetPathType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum HHFileFormat : Swift.String {
    case Jpg
    case Png
    case Jpeg
    case webp
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  @objc override dynamic public init()
  @objc deinit
}
extension HHFileCacheManager {
  public class func getFileFormat(_ name: Swift.String) -> HHDoctorSDK.HHFileCacheManager.HHAssetPathType
  public class func createSoundFilePath(_ aPath: Swift.String) -> Swift.String
  public class func createDBPath(_ aPath: Swift.String) -> Swift.String
  public class func assetsCachePath(_ pathType: HHDoctorSDK.HHFileCacheManager.HHAssetPathType) -> Swift.String
  public class func createImageFilePath(_ format: HHDoctorSDK.HHFileCacheManager.HHFileFormat = .Jpg) -> Swift.String
  public class func getFilePath(_ name: Swift.String) -> Swift.String?
}
extension HHFileCacheManager {
  public static func saveString2File(_ string: Swift.String?, fileName: Swift.String)
  public static func stringFromFile(_ fileName: Swift.String) -> Swift.String?
}
public var uploadManager: HHDoctorSDK.UploadQueue {
  get
}
public class UploadQueue {
  @discardableResult
  public func upload(files: [Swift.String], config: HHDoctorSDK.SDKUploadConfig) -> HHDoctorSDK.HHFileUploadManager
  public func cancelAll(_ finished: (() -> Swift.Void)? = nil)
  @objc deinit
}
public class HHFileUploadManager {
  public var mFileQueue: [Swift.String]
  public var config: HHDoctorSDK.SDKUploadConfig!
  public var mTransFile: Swift.String?
  public var isUploading: Swift.Bool
  public init(files: [Swift.String], config: HHDoctorSDK.SDKUploadConfig)
  public func uploadFile(_ file: [Swift.String])
  public func cancalFiles(_ files: [Swift.String], cancelFinish: ((Swift.String) -> Swift.Void)? = nil)
  public func cancelAll(_ finished: (() -> Swift.Void)? = nil)
  @objc deinit
}
public protocol HHHUDable {
  var autoDismissDuration: Foundation.TimeInterval { get }
  func showHUD()
  func dismissHUD()
  func showSuccess(_ message: Swift.String?)
  func showError(_ messgae: Swift.String?)
  func setDismissDuration(_ duraion: Foundation.TimeInterval)
}
extension HHHUDable {
  public var autoDismissDuration: Foundation.TimeInterval {
    get
  }
  public func setDismissDuration(_ duraion: Foundation.TimeInterval)
}
public struct HHLoginModel : HHDoctorSDK.Mappable {
  public var sessionId: Swift.String
  public var mail: Swift.String?
  public init?(map: HHDoctorSDK.Map)
  mutating public func mapping(map: HHDoctorSDK.Map)
}
public enum HHLogMode : Swift.Int {
  case error
  case warn
  case info
  case debug
  case verbose
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public func logging(type: HHDoctorSDK.HHLogMode = .info, _ tip: Swift.String)
@objc open class HHMediaStatusCheckUtils : ObjectiveC.NSObject {
  open class func checkCameraAccess() -> Swift.Bool
  open class func checkCameraVideoPermission() -> Swift.Bool
  open class func checkAlbumAccess() -> Swift.Bool
  open class func checkAudioAccess() -> Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
public typealias HHLoginHandler = ((Swift.Error?) -> Swift.Void)
@objc public class HHMSDK : ObjectiveC.NSObject {
  @objc public static let `default`: HHDoctorSDK.HHMSDK
  @objc public func start(option: HHDoctorSDK.HHSDKOptions? = nil)
  @objc public func login(userToken: Swift.String, completion: @escaping HHDoctorSDK.HHLoginHandler)
  @available(*, deprecated, message: "Use login(userToken: String, completion: @escaping HHLoginHandler) instead.")
  @objc public func login(uuid: Swift.Int, completion: @escaping HHDoctorSDK.HHLoginHandler)
  @objc public func autoLogin(uuid: Swift.Int)
  @objc public func logout(_ callback: ((Swift.String?) -> Swift.Void)? = nil)
  @objc public func getMedicDetail(userToken: Swift.String, medicId: Swift.String) -> Swift.String
  @objc public func getMedicList(userToken: Swift.String) -> Swift.String
  @objc public func getAllMedics(userToken: Swift.String) -> Swift.String
  @objc public func skipChatHome(skipType: HHDoctorSDK.SkipType = .push, vc: UIKit.UIViewController? = nil)
  @objc public func chatHomeVC() -> UIKit.UIViewController?
  @objc public func startTeamCall(_ type: HHDoctorSDK.HHCallType, callee: HHDoctorSDK.HHCallerInfo)
  @objc public func startCall(_ type: HHDoctorSDK.HHCallType)
  @objc public func startNewCall(_ uuid: Swift.Int)
  @objc public func startCallBy(_ from: Swift.String, type: HHDoctorSDK.HHCallType, delegate: HHDoctorSDK.HHCallDelegate? = nil)
  @objc public func terminate()
  @objc public func updateAPNS(token: Foundation.Data)
  @objc public var SDKVersion: Swift.String {
    @objc get
  }
  @objc public var isLogined: Swift.Bool {
    @objc get
  }
  public static func handle(_ url: Foundation.URL) -> Swift.Bool
  @objc public func add(delegate: HHDoctorSDK.HHMVideoDelegate)
  @objc public func remove(delegate: HHDoctorSDK.HHMVideoDelegate)
  @objc public func markRead() -> Swift.Int
  @objc override dynamic public init()
  @objc deinit
}
extension HHMSDK {
  @objc dynamic public func startMemberCall(needSelectMember: Swift.Bool = true)
}
@objc public enum HHMLoginCode : Swift.Int {
  case OK = 0
  case netError = -1
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum SkipType : Swift.Int {
  case push
  case present
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum HHCallType : Swift.Int {
  case child = 600000
  case adult = 600002
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public struct RemoteData : HHDoctorSDK.Mappable {
  public var cardIdActiveShow: Swift.Int
  public var changeDoctorTime: Swift.Int
  public init?(map: HHDoctorSDK.Map)
  mutating public func mapping(map: HHDoctorSDK.Map)
}
@objc public enum HHMCallingState : Swift.Int {
  case onStart = 0
  case waitingDoctor
  case callFreeDoctor
  case callConnect
  case didRing
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol HHMVideoDelegate : ObjectiveC.NSObjectProtocol {
  @objc optional func callStateChange(_ state: HHDoctorSDK.HHMCallingState)
  @objc optional func callDidEstablish()
  @objc optional func getChatParentView(_ view: UIKit.UIView)
  @objc optional func callFail(code: Swift.Int, error: Swift.String)
  @objc optional func onFail(error: Swift.Error)
  @objc optional func onCancel()
  @objc optional func receivedOrder(_ orderId: Swift.String)
  @objc optional func callDidFinish()
  @objc optional func onExtensionDoctor()
  @objc optional func onReceive(_ callID: Swift.String)
  @objc optional func onResponse(_ accept: Swift.Bool)
  @objc optional func onLeakPermission(_ type: HHDoctorSDK.PermissionType)
}
@objc public protocol HHCallDelegate : ObjectiveC.NSObjectProtocol {
  @objc optional func onCallStatus(_ error: Swift.Error?)
  @objc optional func callFinished()
}
public class HHNetCallChatInfo {
  public init()
  @objc deinit
}
public typealias HHNetError = ((Swift.String) -> (Swift.Void))
public typealias HHNetSuccessNoData = () -> Swift.Void
public typealias NetResult = (Swift.Bool, Swift.String) -> (Swift.Void)
public enum HHRequestMethod {
  case get
  case post
  public static func == (a: HHDoctorSDK.HHRequestMethod, b: HHDoctorSDK.HHRequestMethod) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum HHServerType {
  case pay
  case pacs
  case weixin
  public static func == (a: HHDoctorSDK.HHServerType, b: HHDoctorSDK.HHServerType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public let HH_RELOGIN_NOTIFICATION_STR: Swift.String
public struct HHRequestData {
  public init(body: [Swift.String : Any] = ["default_sw":"default"], param: [Swift.String : Any] = ["default_sw":"default"])
}
@objc open class HHNetObserver : ObjectiveC.NSObject {
  public static let sharedInstance: HHDoctorSDK.HHNetObserver
  open func createReachability()
  open func currentInWifi() -> Swift.Bool
  open func haveNetWork() -> Swift.Bool
  @objc deinit
}
extension UIControl.State : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
}
@objc @IBDesignable public class HHPagerView : UIKit.UIView, UIKit.UICollectionViewDataSource, UIKit.UICollectionViewDelegate {
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic public func layoutSubviews()
  @objc override dynamic public func willMove(toWindow newWindow: UIKit.UIWindow?)
  @objc override dynamic public func prepareForInterfaceBuilder()
  @objc deinit
  @objc public func numberOfSections(in collectionView: UIKit.UICollectionView) -> Swift.Int
  @objc public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @objc public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
  @objc public func collectionView(_ collectionView: UIKit.UICollectionView, shouldHighlightItemAt indexPath: Foundation.IndexPath) -> Swift.Bool
  @objc public func collectionView(_ collectionView: UIKit.UICollectionView, didHighlightItemAt indexPath: Foundation.IndexPath)
  @objc public func collectionView(_ collectionView: UIKit.UICollectionView, shouldSelectItemAt indexPath: Foundation.IndexPath) -> Swift.Bool
  @objc public func collectionView(_ collectionView: UIKit.UICollectionView, didSelectItemAt indexPath: Foundation.IndexPath)
  @objc public func collectionView(_ collectionView: UIKit.UICollectionView, willDisplay cell: UIKit.UICollectionViewCell, forItemAt indexPath: Foundation.IndexPath)
  @objc public func collectionView(_ collectionView: UIKit.UICollectionView, didEndDisplaying cell: UIKit.UICollectionViewCell, forItemAt indexPath: Foundation.IndexPath)
  @objc public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  @objc public func scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView)
  @objc public func scrollViewWillEndDragging(_ scrollView: UIKit.UIScrollView, withVelocity velocity: CoreGraphics.CGPoint, targetContentOffset: Swift.UnsafeMutablePointer<CoreGraphics.CGPoint>)
  @objc public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @objc public func scrollViewDidEndScrollingAnimation(_ scrollView: UIKit.UIScrollView)
}
@objc public enum HHPagerViewTransformerType : Swift.Int {
  case crossFading
  case zoomOut
  case depth
  case overlap
  case linear
  case coverFlow
  case ferrisWheel
  case invertedFerrisWheel
  case cubic
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public class HHPhotoPicker {
  public static func openCamera(config: HHDoctorSDK.HHCameraConfig, capFinished: HHDoctorSDK.onCapFinished? = nil)
  public static func reduceImages(paths: [Swift.String], finished: @escaping (([Swift.String]) -> Swift.Void))
  public class func changeAvatar(vc: UIKit.UIViewController, reference: UIKit.UIView? = nil, uuid: Swift.Int, imgClosure: @escaping (UIKit.UIImage) -> Swift.Void, keyClosure: @escaping (Swift.String) -> Swift.Void)
  @objc deinit
}
extension HHPhotoPicker {
  public static func checkPermisstion(_ type: HHDoctorSDK.PermissionType, authorized: (() -> Swift.Void)?, others: ((HHDoctorSDK.PermissionType) -> Swift.Void)?)
  public static func converSize(_ size: CoreGraphics.CGSize) -> CoreGraphics.CGSize
}
@objc public class HHPhotoPickerController : UIKit.UINavigationController {
  @objc override dynamic public func viewDidLoad()
  convenience public init(localPath: Swift.String? = nil, deleteMode: Swift.Bool = false, finish: (([HHDoctorSDK.SDKCameraImageModel]?) -> Swift.Void)? = nil)
  @objc deinit
  @available(iOS 5.0, *)
  @objc override dynamic public init(navigationBarClass: Swift.AnyClass?, toolbarClass: Swift.AnyClass?)
  @objc override dynamic public init(rootViewController: UIKit.UIViewController)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
}
public class HHProgressHUD : HHDoctorSDK.HHHUDable {
  public init()
  public func showHUD()
  public func dismissHUD()
  public func showError(_ messgae: Swift.String?)
  public func showSuccess(_ message: Swift.String?)
  public func hhMessageTips(message: Swift.String?)
  @objc deinit
}
public let KeyNetErrorStr: Swift.String
public class HHRequest<T> where T : HHDoctorSDK.Mappable {
  public typealias HHNetSuccess = (T) -> Swift.Void
  public typealias HHNetSuccessForArray = ([T]) -> Swift.Void
  public var mRequestFail: HHDoctorSDK.HHNetError?
  public var mRequestSuccess: HHDoctorSDK.HHRequest<T>.HHNetSuccess?
  public var mRequestSuccessNoData: HHDoctorSDK.HHNetSuccessNoData?
  public var mRequestSuccessForArray: HHDoctorSDK.HHRequest<T>.HHNetSuccessForArray?
  required public init(aRequestConfig: HHDoctorSDK.HHRequestConfig, requestData: HHDoctorSDK.HHRequestData? = nil)
  public func start()
  @objc deinit
}
@objc public class HHLocation : ObjectiveC.NSObject {
  @objc public static let `default`: HHDoctorSDK.HHLocation
  @objc public func startLocation(lng: Swift.String, lat: Swift.String)
  @objc public func closeLocation()
  @objc override dynamic public init()
  @objc deinit
}
public protocol HHRequestConfig {
  func serviceURLSuffix() -> Swift.String
  func isNeedUserInfo() -> Swift.Bool?
  func requestMethod() -> HHDoctorSDK.HHRequestMethod
  func requestType() -> HHDoctorSDK.HHServerType
  func extensionUrlHost() -> Swift.String?
  func needSaveCache() -> Swift.Bool
  func cacheKey() -> Swift.String?
  func needDNS() -> Swift.Bool
  func needEncrypt() -> Swift.Bool
}
extension HHRequestConfig {
  public func needSaveCache() -> Swift.Bool
  public func cacheKey() -> Swift.String?
  public func isNeedUserInfo() -> Swift.Bool?
  public func requestMethod() -> HHDoctorSDK.HHRequestMethod
  public func requestType() -> HHDoctorSDK.HHServerType
  public func extensionUrlHost() -> Swift.String?
  public func isHaveExtensionUrl() -> Swift.Bool
  public func needDNS() -> Swift.Bool
  public func needEncrypt() -> Swift.Bool
}
extension HHRequest {
  public func startForArray(_ successCallBack: @escaping HHDoctorSDK.HHRequest<T>.HHNetSuccessForArray, failCallBack: @escaping HHDoctorSDK.HHNetError)
}
public var HMDefaultOpt: HHDoctorSDK.HHSDKOptions {
  get
}
public var HMHudManager: HHDoctorSDK.HHHUDable {
  get
}
@objc public class HHSDKOptions : ObjectiveC.NSObject {
  @objc public static let `default`: HHDoctorSDK.HHSDKOptions
  public var hudManager: HHDoctorSDK.HHHUDable
  @objc public var isDebug: Swift.Bool
  @objc public var isDevelopment: Swift.Bool
  @objc public var sdkProductId: Swift.String
  @objc public var cerName: Swift.String?
  @objc public var mExtensionString: Swift.String
  @objc public var mAlineWebToZero: Swift.Bool
  @objc public var changeDoctorTime: Swift.Int
  @objc public var shouldWaingCall: Swift.Bool
  public static let hud: HHDoctorSDK.HHHUDable
  @objc public var hudDisTime: Foundation.TimeInterval {
    @objc get
    @objc set
  }
  @objc public var mVideoOptions: HHDoctorSDK.VideoOptions
  @objc public var mMessageOptions: HHDoctorSDK.MessageOptions
  @objc public var mUserCenterOptions: HHDoctorSDK.UsercenterOptions
  public var addrCallback: ((UIKit.UIView) -> Swift.Void)?
  public var logCallback: ((Swift.String) -> Swift.Void)?
  public var videoUploadImgCallback: ((Swift.String, [Swift.String]) -> Swift.Void)?
  @objc public init(sdkProductId: Swift.String, isDebug: Swift.Bool = true, isDevelop: Swift.Bool = true)
  public func ignoreVersion(_ version: Swift.String)
  public func getSDKVersion() -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
@objc public class VideoOptions : ObjectiveC.NSObject {
  @objc public var allowBeauty: Swift.Bool
  @objc public var allowEvaluate: Swift.Bool
  @objc public var allowAddMember: Swift.Bool
  @objc public var allowMulti: Swift.Bool
  @objc public var isShowDocInfo: Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
@objc public class MessageOptions : ObjectiveC.NSObject {
  @objc public var isFilterSummary: Swift.Bool
  @objc public var isFilterMedicinal: Swift.Bool
  @objc public var defaultDocHeader: Swift.String
  @objc public var defaultDocName: Swift.String
  @objc public var messageTitle: Swift.String
  @objc public var isByPresent: Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
@objc public class UsercenterOptions : ObjectiveC.NSObject {
  @objc public var enableVipInfo: Swift.Bool
  @objc public var hideUserCenter: Swift.Bool
  @objc public var enableActivate: Swift.Bool
  @objc public var enableMedical: Swift.Bool
  @objc public var enableAddMemberInDoc: Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
public enum hhToastPosition {
  case top
  case center
  case bottom
  public static func == (a: HHDoctorSDK.hhToastPosition, b: HHDoctorSDK.hhToastPosition) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension UIView {
  public func hhmakeToast(_ message: Swift.String)
  public func hhmakeToast(_ message: Swift.String, duration: Foundation.TimeInterval, position: HHDoctorSDK.hhToastPosition)
  public func hhmakeToast(_ message: Swift.String, duration: Foundation.TimeInterval, position: CoreGraphics.CGPoint)
  public func hhmakeToast(_ message: Swift.String, duration: Foundation.TimeInterval, position: HHDoctorSDK.hhToastPosition, style: HHDoctorSDK.hhToastStyle?)
  public func hhmakeToast(_ message: Swift.String, duration: Foundation.TimeInterval, position: CoreGraphics.CGPoint, style: HHDoctorSDK.hhToastStyle?)
  public func hhmakeToast(_ message: Swift.String?, duration: Foundation.TimeInterval, position: HHDoctorSDK.hhToastPosition, title: Swift.String?, image: UIKit.UIImage?, style: HHDoctorSDK.hhToastStyle?, completion: ((Swift.Bool) -> Swift.Void)?)
  public func hhmakeToast(_ message: Swift.String?, duration: Foundation.TimeInterval, position: CoreGraphics.CGPoint, title: Swift.String?, image: UIKit.UIImage?, style: HHDoctorSDK.hhToastStyle?, completion: ((Swift.Bool) -> Swift.Void)?)
  public func hhshowToast(_ toast: UIKit.UIView)
  public func hhshowToast(_ toast: UIKit.UIView, duration: Foundation.TimeInterval, position: HHDoctorSDK.hhToastPosition, completion: ((Swift.Bool) -> Swift.Void)?)
  public func hhshowToast(_ toast: UIKit.UIView, duration: Foundation.TimeInterval, position: CoreGraphics.CGPoint, completion: ((Swift.Bool) -> Swift.Void)?)
  public func hhmakeToastActivity(_ position: HHDoctorSDK.hhToastPosition)
  public func hhmakeToastActivity(_ position: CoreGraphics.CGPoint)
  public func hhhideToastActivity()
  @objc dynamic public func hhhandleToastTapped(_ recognizer: UIKit.UITapGestureRecognizer)
  @objc dynamic public func hhtoastTimerDidFinish(_ timer: Foundation.Timer)
  public func hhtoastViewForMessage(_ message: Swift.String?, title: Swift.String?, image: UIKit.UIImage?, style: HHDoctorSDK.hhToastStyle) throws -> UIKit.UIView
}
public struct hhToastStyle {
  public init()
  public var backgroundColor: UIKit.UIColor
  public var titleColor: UIKit.UIColor
  public var messageColor: UIKit.UIColor
  public var maxWidthPercentage: CoreGraphics.CGFloat {
    get
    set
  }
  public var maxHeightPercentage: CoreGraphics.CGFloat {
    get
    set
  }
  public var horizontalPadding: CoreGraphics.CGFloat
  public var verticalPadding: CoreGraphics.CGFloat
  public var cornerRadius: CoreGraphics.CGFloat
  public var titleFont: UIKit.UIFont
  public var messageFont: UIKit.UIFont
  public var titleAlignment: UIKit.NSTextAlignment
  public var messageAlignment: UIKit.NSTextAlignment
  public var titleNumberOfLines: Swift.Int
  public var messageNumberOfLines: Swift.Int
  public var displayShadow: Swift.Bool
  public var shadowColor: UIKit.UIColor
  public var shadowOpacity: Swift.Float {
    get
    set
  }
  public var shadowRadius: CoreGraphics.CGFloat
  public var shadowOffset: CoreGraphics.CGSize
  public var imageSize: CoreGraphics.CGSize
  public var activitySize: CoreGraphics.CGSize
  public var fadeDuration: Foundation.TimeInterval
}
public class HHUrl {
  @objc deinit
}
extension HHUrl {
  public static func param2String(param: [Swift.String : Any]? = nil) -> Swift.String
}
public class HHUserDefaults {
  public class func setString(_ str: Swift.String, key: Swift.String)
  public class func stringValue(_ key: Swift.String) -> Swift.String?
  public class func setArray(_ array: [Swift.AnyObject], key: Swift.String)
  public class func arrayForKey(_ key: Swift.String) -> [Swift.AnyObject]?
  public class func setImage(_ image: UIKit.UIImage, key: Swift.String)
  public class func imageForKey(_ key: Swift.String) -> UIKit.UIImage?
  @objc deinit
}
extension HHUserDefaults {
  public class func setBool(_ flag: Swift.Bool, key: Swift.String)
  public class func boolForKey(_ key: Swift.String) -> Swift.Bool
  public class func setObject(_ obj: Swift.AnyObject, key: Swift.String)
  public class func objectForKey(_ key: Swift.String) -> Swift.AnyObject?
  public class func removeObject(_ key: Swift.String)
}
extension HHUserDefaults {
  public class func setData(_ data: Foundation.Data?, key: Swift.String)
  public class func dataForKey(_ key: Swift.String) -> Foundation.Data?
  public class func userDefaults() -> Foundation.UserDefaults
  public class func synchronize()
  public class func encryptkey(_ key: Swift.String) -> Swift.String
}
public class HHUserModel : HHDoctorSDK.Mappable {
  public var product: HHDoctorSDK.HHMemberInfoModel?
  public var uuid: Swift.Int?
  public var isMember: Swift.Bool?
  required public init?(map: HHDoctorSDK.Map)
  public func mapping(map: HHDoctorSDK.Map)
  @objc deinit
}
public struct HHMemberInfoModel : HHDoctorSDK.Mappable {
  public var productStatusDescn: Swift.String?
  public init?(map: HHDoctorSDK.Map)
  mutating public func mapping(map: HHDoctorSDK.Map)
}
open class HHValueObservable<T> {
  public typealias Observer = (T) -> Swift.Void
  open var observer: HHDoctorSDK.HHValueObservable<T>.Observer?
  open func observe(_ observer: HHDoctorSDK.HHValueObservable<T>.Observer?)
  open var value: T {
    get
    set
  }
  public init(_ v: T)
  @objc deinit
}
public struct HKDF {
  public enum Error : Swift.Error {
    case invalidInput
    case derivedKeyTooLong
    public static func == (a: HHDoctorSDK.HKDF.Error, b: HHDoctorSDK.HKDF.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>? = nil, info: Swift.Array<Swift.UInt8>? = nil, keyLength: Swift.Int? = nil, variant: HHDoctorSDK.HMAC.Variant = .sha256) throws
  public func calculate() throws -> Swift.Array<Swift.UInt8>
}
extension HMAC {
  convenience public init(key: Swift.String, variant: HHDoctorSDK.HMAC.Variant = .md5) throws
}
final public class HMAC : HHDoctorSDK.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    case invalidInput
    public static func == (a: HHDoctorSDK.HMAC.Error, b: HHDoctorSDK.HMAC.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum Variant {
    case sha1, sha256, sha384, sha512, md5
    public static func == (a: HHDoctorSDK.HMAC.Variant, b: HHDoctorSDK.HMAC.Variant) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init(key: Swift.Array<Swift.UInt8>, variant: HHDoctorSDK.HMAC.Variant = .md5)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public protocol ImmutableMappable : HHDoctorSDK.BaseMappable {
  init(map: HHDoctorSDK.Map) throws
}
extension ImmutableMappable {
  public func mapping(map: HHDoctorSDK.Map)
  public init(JSONString: Swift.String, context: HHDoctorSDK.MapContext? = nil) throws
  public init(JSON: [Swift.String : Any], context: HHDoctorSDK.MapContext? = nil) throws
  public init(JSONObject: Any, context: HHDoctorSDK.MapContext? = nil) throws
}
extension Map {
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> Transform.Object where Transform : HHDoctorSDK.TransformType
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T where T : Swift.RawRepresentable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T] where T : Swift.RawRepresentable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T where T : HHDoctorSDK.BaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T] where T : HHDoctorSDK.BaseMappable
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Transform.Object] where Transform : HHDoctorSDK.TransformType
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Swift.String : T] where T : HHDoctorSDK.BaseMappable
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Swift.String : Transform.Object] where Transform : HHDoctorSDK.TransformType
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [[T]] where T : HHDoctorSDK.BaseMappable
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [[Transform.Object]] where Transform : HHDoctorSDK.TransformType
}
extension Mapper where N : HHDoctorSDK.ImmutableMappable {
  final public func map(JSON: [Swift.String : Any]) throws -> N
  final public func map(JSONString: Swift.String) throws -> N
  final public func map(JSONObject: Any) throws -> N
  final public func mapArray(JSONArray: [[Swift.String : Any]]) throws -> [N]
  final public func mapArray(JSONString: Swift.String) throws -> [N]
  final public func mapArray(JSONObject: Any) throws -> [N]
  final public func mapDictionary(JSONString: Swift.String) throws -> [Swift.String : N]
  final public func mapDictionary(JSONObject: Any?) throws -> [Swift.String : N]
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]]) throws -> [Swift.String : N]
  final public func mapDictionaryOfArrays(JSONObject: Any?) throws -> [Swift.String : [N]]
  final public func mapDictionaryOfArrays(JSON: [Swift.String : [[Swift.String : Any]]]) throws -> [Swift.String : [N]]
  final public func mapArrayOfArrays(JSONObject: Any?) throws -> [[N]]
}
public func <- <T>(left: inout T, right: HHDoctorSDK.Map) where T : Swift.SignedInteger
public func <- <T>(left: inout T?, right: HHDoctorSDK.Map) where T : Swift.SignedInteger
public func <- <T>(left: inout T, right: HHDoctorSDK.Map) where T : Swift.UnsignedInteger
public func <- <T>(left: inout T?, right: HHDoctorSDK.Map) where T : Swift.UnsignedInteger
extension DateFormatter {
  convenience public init(withFormat format: Swift.String, locale: Swift.String)
}
open class ISO8601DateTransform : HHDoctorSDK.DateFormatterTransform {
  public init()
  override public init(dateFormatter: Foundation.DateFormatter)
  @objc deinit
}
public let KeychainAccessErrorDomain: Swift.String
public enum ItemClass {
  case genericPassword
  case internetPassword
}
public enum ProtocolType {
  case ftp
  case ftpAccount
  case http
  case irc
  case nntp
  case pop3
  case smtp
  case socks
  case imap
  case ldap
  case appleTalk
  case afp
  case telnet
  case ssh
  case ftps
  case https
  case httpProxy
  case httpsProxy
  case ftpProxy
  case smb
  case rtsp
  case rtspProxy
  case daap
  case eppc
  case ipp
  case nntps
  case ldaps
  case telnetS
  case imaps
  case ircs
  case pop3S
}
public enum AuthenticationType {
  case ntlm
  case msn
  case dpa
  case rpa
  case httpBasic
  case httpDigest
  case htmlForm
  case `default`
}
public enum Accessibility {
  case whenUnlocked
  case afterFirstUnlock
  case always
  @available(iOS 8.0, OSX 10.10, *)
  case whenPasscodeSetThisDeviceOnly
  case whenUnlockedThisDeviceOnly
  case afterFirstUnlockThisDeviceOnly
  case alwaysThisDeviceOnly
}
public struct AuthenticationPolicy : Swift.OptionSet {
  @available(iOS 8.0, OSX 10.10, *)
  @available(watchOS, unavailable)
  public static let userPresence: HHDoctorSDK.AuthenticationPolicy
  @available(iOS 9.0, *)
  @available(OSX, unavailable)
  @available(watchOS, unavailable)
  public static let touchIDAny: HHDoctorSDK.AuthenticationPolicy
  @available(iOS 9.0, *)
  @available(OSX, unavailable)
  @available(watchOS, unavailable)
  public static let touchIDCurrentSet: HHDoctorSDK.AuthenticationPolicy
  @available(iOS 9.0, OSX 10.11, *)
  @available(watchOS, unavailable)
  public static let devicePasscode: HHDoctorSDK.AuthenticationPolicy
  @available(iOS 9.0, *)
  @available(OSX, unavailable)
  @available(watchOS, unavailable)
  public static let or: HHDoctorSDK.AuthenticationPolicy
  @available(iOS 9.0, *)
  @available(OSX, unavailable)
  @available(watchOS, unavailable)
  public static let and: HHDoctorSDK.AuthenticationPolicy
  @available(iOS 9.0, *)
  @available(OSX, unavailable)
  @available(watchOS, unavailable)
  public static let privateKeyUsage: HHDoctorSDK.AuthenticationPolicy
  @available(iOS 9.0, *)
  @available(OSX, unavailable)
  @available(watchOS, unavailable)
  public static let applicationPassword: HHDoctorSDK.AuthenticationPolicy
  public let rawValue: Swift.UInt
  public init(rawValue: Swift.UInt)
  public typealias Element = HHDoctorSDK.AuthenticationPolicy
  public typealias ArrayLiteralElement = HHDoctorSDK.AuthenticationPolicy
  public typealias RawValue = Swift.UInt
}
public struct Attributes {
  public var `class`: Swift.String? {
    get
  }
  public var data: Foundation.Data? {
    get
  }
  public var ref: Foundation.Data? {
    get
  }
  public var persistentRef: Foundation.Data? {
    get
  }
  public var accessible: Swift.String? {
    get
  }
  public var accessControl: Security.SecAccessControl? {
    get
  }
  public var accessGroup: Swift.String? {
    get
  }
  public var synchronizable: Swift.Bool? {
    get
  }
  public var creationDate: Foundation.Date? {
    get
  }
  public var modificationDate: Foundation.Date? {
    get
  }
  public var attributeDescription: Swift.String? {
    get
  }
  public var comment: Swift.String? {
    get
  }
  public var creator: Swift.String? {
    get
  }
  public var type: Swift.String? {
    get
  }
  public var label: Swift.String? {
    get
  }
  public var isInvisible: Swift.Bool? {
    get
  }
  public var isNegative: Swift.Bool? {
    get
  }
  public var account: Swift.String? {
    get
  }
  public var service: Swift.String? {
    get
  }
  public var generic: Foundation.Data? {
    get
  }
  public var securityDomain: Swift.String? {
    get
  }
  public var server: Swift.String? {
    get
  }
  public var `protocol`: Swift.String? {
    get
  }
  public var authenticationType: Swift.String? {
    get
  }
  public var port: Swift.Int? {
    get
  }
  public var path: Swift.String? {
    get
  }
  public subscript(key: Swift.String) -> Any? {
    get
  }
}
final public class Keychain {
  final public var itemClass: HHDoctorSDK.ItemClass {
    get
  }
  final public var service: Swift.String {
    get
  }
  final public var accessGroup: Swift.String? {
    get
  }
  final public var server: Foundation.URL {
    get
  }
  final public var protocolType: HHDoctorSDK.ProtocolType {
    get
  }
  final public var authenticationType: HHDoctorSDK.AuthenticationType {
    get
  }
  final public var accessibility: HHDoctorSDK.Accessibility {
    get
  }
  @available(iOS 8.0, OSX 10.10, *)
  @available(watchOS, unavailable)
  final public var authenticationPolicy: HHDoctorSDK.AuthenticationPolicy? {
    get
  }
  final public var synchronizable: Swift.Bool {
    get
  }
  final public var label: Swift.String? {
    get
  }
  final public var comment: Swift.String? {
    get
  }
  @available(iOS 8.0, OSX 10.10, *)
  @available(watchOS, unavailable)
  final public var authenticationPrompt: Swift.String? {
    get
  }
  @available(iOS 9.0, OSX 10.11, *)
  final public var authenticationContext: LocalAuthentication.LAContext? {
    get
  }
  convenience public init()
  convenience public init(service: Swift.String)
  convenience public init(accessGroup: Swift.String)
  convenience public init(service: Swift.String, accessGroup: Swift.String)
  convenience public init(server: Swift.String, protocolType: HHDoctorSDK.ProtocolType, authenticationType: HHDoctorSDK.AuthenticationType = .default)
  convenience public init(server: Foundation.URL, protocolType: HHDoctorSDK.ProtocolType, authenticationType: HHDoctorSDK.AuthenticationType = .default)
  final public func accessibility(_ accessibility: HHDoctorSDK.Accessibility) -> HHDoctorSDK.Keychain
  @available(iOS 8.0, OSX 10.10, *)
  @available(watchOS, unavailable)
  final public func accessibility(_ accessibility: HHDoctorSDK.Accessibility, authenticationPolicy: HHDoctorSDK.AuthenticationPolicy) -> HHDoctorSDK.Keychain
  final public func synchronizable(_ synchronizable: Swift.Bool) -> HHDoctorSDK.Keychain
  final public func label(_ label: Swift.String) -> HHDoctorSDK.Keychain
  final public func comment(_ comment: Swift.String) -> HHDoctorSDK.Keychain
  final public func attributes(_ attributes: [Swift.String : Any]) -> HHDoctorSDK.Keychain
  @available(iOS 8.0, OSX 10.10, *)
  @available(watchOS, unavailable)
  final public func authenticationPrompt(_ authenticationPrompt: Swift.String) -> HHDoctorSDK.Keychain
  @available(iOS 9.0, OSX 10.11, *)
  final public func authenticationContext(_ authenticationContext: LocalAuthentication.LAContext) -> HHDoctorSDK.Keychain
  final public func get(_ key: Swift.String) throws -> Swift.String?
  final public func getString(_ key: Swift.String) throws -> Swift.String?
  final public func getData(_ key: Swift.String) throws -> Foundation.Data?
  final public func get<T>(_ key: Swift.String, handler: (HHDoctorSDK.Attributes?) -> T) throws -> T
  final public func set(_ value: Swift.String, key: Swift.String) throws
  final public func set(_ value: Foundation.Data, key: Swift.String) throws
  final public subscript(key: Swift.String) -> Swift.String? {
    get
    set
  }
  final public subscript(string key: Swift.String) -> Swift.String? {
    get
    set
  }
  final public subscript(data key: Swift.String) -> Foundation.Data? {
    get
    set
  }
  final public subscript(attributes key: Swift.String) -> HHDoctorSDK.Attributes? {
    get
  }
  final public func remove(_ key: Swift.String) throws
  final public func removeAll() throws
  final public func contains(_ key: Swift.String) throws -> Swift.Bool
  final public class func allKeys(_ itemClass: HHDoctorSDK.ItemClass) -> [(Swift.String, Swift.String)]
  final public func allKeys() -> [Swift.String]
  final public class func allItems(_ itemClass: HHDoctorSDK.ItemClass) -> [[Swift.String : Any]]
  final public func allItems() -> [[Swift.String : Any]]
  @available(iOS 8.0, *)
  final public func getSharedPassword(_ completion: @escaping (Swift.String?, Swift.String?, Swift.Error?) -> () = { account, password, error -> () in })
  @available(iOS 8.0, *)
  final public func getSharedPassword(_ account: Swift.String, completion: @escaping (Swift.String?, Swift.Error?) -> () = { password, error -> () in })
  @available(iOS 8.0, *)
  final public func setSharedPassword(_ password: Swift.String, account: Swift.String, completion: @escaping (Swift.Error?) -> () = { e -> () in })
  @available(iOS 8.0, *)
  final public func removeSharedPassword(_ account: Swift.String, completion: @escaping (Swift.Error?) -> () = { e -> () in })
  @available(iOS 8.0, *)
  final public class func requestSharedWebCredential(_ completion: @escaping ([[Swift.String : Swift.String]], Swift.Error?) -> () = { credentials, error -> () in })
  @available(iOS 8.0, *)
  final public class func requestSharedWebCredential(domain: Swift.String, completion: @escaping ([[Swift.String : Swift.String]], Swift.Error?) -> () = { credentials, error -> () in })
  @available(iOS 8.0, *)
  final public class func requestSharedWebCredential(domain: Swift.String, account: Swift.String, completion: @escaping ([[Swift.String : Swift.String]], Swift.Error?) -> () = { credentials, error -> () in })
  @available(iOS 8.0, *)
  final public class func generatePassword() -> Swift.String
  @objc deinit
}
extension Keychain : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  final public var description: Swift.String {
    get
  }
  final public var debugDescription: Swift.String {
    get
  }
}
extension Attributes : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension ItemClass : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension ProtocolType : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension AuthenticationType : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension Accessibility : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
public enum Status : Darwin.OSStatus, Swift.Error {
  case success
  case unimplemented
  case diskFull
  case io
  case opWr
  case param
  case wrPerm
  case allocate
  case userCanceled
  case badReq
  case internalComponent
  case notAvailable
  case readOnly
  case authFailed
  case noSuchKeychain
  case invalidKeychain
  case duplicateKeychain
  case duplicateCallback
  case invalidCallback
  case duplicateItem
  case itemNotFound
  case bufferTooSmall
  case dataTooLarge
  case noSuchAttr
  case invalidItemRef
  case invalidSearchRef
  case noSuchClass
  case noDefaultKeychain
  case interactionNotAllowed
  case readOnlyAttr
  case wrongSecVersion
  case keySizeNotAllowed
  case noStorageModule
  case noCertificateModule
  case noPolicyModule
  case interactionRequired
  case dataNotAvailable
  case dataNotModifiable
  case createChainFailed
  case invalidPrefsDomain
  case inDarkWake
  case aclNotSimple
  case policyNotFound
  case invalidTrustSetting
  case noAccessForItem
  case invalidOwnerEdit
  case trustNotAvailable
  case unsupportedFormat
  case unknownFormat
  case keyIsSensitive
  case multiplePrivKeys
  case passphraseRequired
  case invalidPasswordRef
  case invalidTrustSettings
  case noTrustSettings
  case pkcs12VerifyFailure
  case invalidCertificate
  case notSigner
  case policyDenied
  case invalidKey
  case decode
  case `internal`
  case unsupportedAlgorithm
  case unsupportedOperation
  case unsupportedPadding
  case itemInvalidKey
  case itemInvalidKeyType
  case itemInvalidValue
  case itemClassMissing
  case itemMatchUnsupported
  case useItemListUnsupported
  case useKeychainUnsupported
  case useKeychainListUnsupported
  case returnDataUnsupported
  case returnAttributesUnsupported
  case returnRefUnsupported
  case returnPersitentRefUnsupported
  case valueRefUnsupported
  case valuePersistentRefUnsupported
  case returnMissingPointer
  case matchLimitUnsupported
  case itemIllegalQuery
  case waitForCallback
  case missingEntitlement
  case upgradePending
  case mpSignatureInvalid
  case otrTooOld
  case otrIDTooNew
  case serviceNotAvailable
  case insufficientClientID
  case deviceReset
  case deviceFailed
  case appleAddAppACLSubject
  case applePublicKeyIncomplete
  case appleSignatureMismatch
  case appleInvalidKeyStartDate
  case appleInvalidKeyEndDate
  case conversionError
  case appleSSLv2Rollback
  case quotaExceeded
  case fileTooBig
  case invalidDatabaseBlob
  case invalidKeyBlob
  case incompatibleDatabaseBlob
  case incompatibleKeyBlob
  case hostNameMismatch
  case unknownCriticalExtensionFlag
  case noBasicConstraints
  case noBasicConstraintsCA
  case invalidAuthorityKeyID
  case invalidSubjectKeyID
  case invalidKeyUsageForPolicy
  case invalidExtendedKeyUsage
  case invalidIDLinkage
  case pathLengthConstraintExceeded
  case invalidRoot
  case crlExpired
  case crlNotValidYet
  case crlNotFound
  case crlServerDown
  case crlBadURI
  case unknownCertExtension
  case unknownCRLExtension
  case crlNotTrusted
  case crlPolicyFailed
  case idpFailure
  case smimeEmailAddressesNotFound
  case smimeBadExtendedKeyUsage
  case smimeBadKeyUsage
  case smimeKeyUsageNotCritical
  case smimeNoEmailAddress
  case smimeSubjAltNameNotCritical
  case sslBadExtendedKeyUsage
  case ocspBadResponse
  case ocspBadRequest
  case ocspUnavailable
  case ocspStatusUnrecognized
  case endOfData
  case incompleteCertRevocationCheck
  case networkFailure
  case ocspNotTrustedToAnchor
  case recordModified
  case ocspSignatureError
  case ocspNoSigner
  case ocspResponderMalformedReq
  case ocspResponderInternalError
  case ocspResponderTryLater
  case ocspResponderSignatureRequired
  case ocspResponderUnauthorized
  case ocspResponseNonceMismatch
  case codeSigningBadCertChainLength
  case codeSigningNoBasicConstraints
  case codeSigningBadPathLengthConstraint
  case codeSigningNoExtendedKeyUsage
  case codeSigningDevelopment
  case resourceSignBadCertChainLength
  case resourceSignBadExtKeyUsage
  case trustSettingDeny
  case invalidSubjectName
  case unknownQualifiedCertStatement
  case mobileMeRequestQueued
  case mobileMeRequestRedirected
  case mobileMeServerError
  case mobileMeServerNotAvailable
  case mobileMeServerAlreadyExists
  case mobileMeServerServiceErr
  case mobileMeRequestAlreadyPending
  case mobileMeNoRequestPending
  case mobileMeCSRVerifyFailure
  case mobileMeFailedConsistencyCheck
  case notInitialized
  case invalidHandleUsage
  case pvcReferentNotFound
  case functionIntegrityFail
  case internalError
  case memoryError
  case invalidData
  case mdsError
  case invalidPointer
  case selfCheckFailed
  case functionFailed
  case moduleManifestVerifyFailed
  case invalidGUID
  case invalidHandle
  case invalidDBList
  case invalidPassthroughID
  case invalidNetworkAddress
  case crlAlreadySigned
  case invalidNumberOfFields
  case verificationFailure
  case unknownTag
  case invalidSignature
  case invalidName
  case invalidCertificateRef
  case invalidCertificateGroup
  case tagNotFound
  case invalidQuery
  case invalidValue
  case callbackFailed
  case aclDeleteFailed
  case aclReplaceFailed
  case aclAddFailed
  case aclChangeFailed
  case invalidAccessCredentials
  case invalidRecord
  case invalidACL
  case invalidSampleValue
  case incompatibleVersion
  case privilegeNotGranted
  case invalidScope
  case pvcAlreadyConfigured
  case invalidPVC
  case emmLoadFailed
  case emmUnloadFailed
  case addinLoadFailed
  case invalidKeyRef
  case invalidKeyHierarchy
  case addinUnloadFailed
  case libraryReferenceNotFound
  case invalidAddinFunctionTable
  case invalidServiceMask
  case moduleNotLoaded
  case invalidSubServiceID
  case attributeNotInContext
  case moduleManagerInitializeFailed
  case moduleManagerNotFound
  case eventNotificationCallbackNotFound
  case inputLengthError
  case outputLengthError
  case privilegeNotSupported
  case deviceError
  case attachHandleBusy
  case notLoggedIn
  case algorithmMismatch
  case keyUsageIncorrect
  case keyBlobTypeIncorrect
  case keyHeaderInconsistent
  case unsupportedKeyFormat
  case unsupportedKeySize
  case invalidKeyUsageMask
  case unsupportedKeyUsageMask
  case invalidKeyAttributeMask
  case unsupportedKeyAttributeMask
  case invalidKeyLabel
  case unsupportedKeyLabel
  case invalidKeyFormat
  case unsupportedVectorOfBuffers
  case invalidInputVector
  case invalidOutputVector
  case invalidContext
  case invalidAlgorithm
  case invalidAttributeKey
  case missingAttributeKey
  case invalidAttributeInitVector
  case missingAttributeInitVector
  case invalidAttributeSalt
  case missingAttributeSalt
  case invalidAttributePadding
  case missingAttributePadding
  case invalidAttributeRandom
  case missingAttributeRandom
  case invalidAttributeSeed
  case missingAttributeSeed
  case invalidAttributePassphrase
  case missingAttributePassphrase
  case invalidAttributeKeyLength
  case missingAttributeKeyLength
  case invalidAttributeBlockSize
  case missingAttributeBlockSize
  case invalidAttributeOutputSize
  case missingAttributeOutputSize
  case invalidAttributeRounds
  case missingAttributeRounds
  case invalidAlgorithmParms
  case missingAlgorithmParms
  case invalidAttributeLabel
  case missingAttributeLabel
  case invalidAttributeKeyType
  case missingAttributeKeyType
  case invalidAttributeMode
  case missingAttributeMode
  case invalidAttributeEffectiveBits
  case missingAttributeEffectiveBits
  case invalidAttributeStartDate
  case missingAttributeStartDate
  case invalidAttributeEndDate
  case missingAttributeEndDate
  case invalidAttributeVersion
  case missingAttributeVersion
  case invalidAttributePrime
  case missingAttributePrime
  case invalidAttributeBase
  case missingAttributeBase
  case invalidAttributeSubprime
  case missingAttributeSubprime
  case invalidAttributeIterationCount
  case missingAttributeIterationCount
  case invalidAttributeDLDBHandle
  case missingAttributeDLDBHandle
  case invalidAttributeAccessCredentials
  case missingAttributeAccessCredentials
  case invalidAttributePublicKeyFormat
  case missingAttributePublicKeyFormat
  case invalidAttributePrivateKeyFormat
  case missingAttributePrivateKeyFormat
  case invalidAttributeSymmetricKeyFormat
  case missingAttributeSymmetricKeyFormat
  case invalidAttributeWrappedKeyFormat
  case missingAttributeWrappedKeyFormat
  case stagedOperationInProgress
  case stagedOperationNotStarted
  case verifyFailed
  case querySizeUnknown
  case blockSizeMismatch
  case publicKeyInconsistent
  case deviceVerifyFailed
  case invalidLoginName
  case alreadyLoggedIn
  case invalidDigestAlgorithm
  case invalidCRLGroup
  case certificateCannotOperate
  case certificateExpired
  case certificateNotValidYet
  case certificateRevoked
  case certificateSuspended
  case insufficientCredentials
  case invalidAction
  case invalidAuthority
  case verifyActionFailed
  case invalidCertAuthority
  case invaldCRLAuthority
  case invalidCRLEncoding
  case invalidCRLType
  case invalidCRL
  case invalidFormType
  case invalidID
  case invalidIdentifier
  case invalidIndex
  case invalidPolicyIdentifiers
  case invalidTimeString
  case invalidReason
  case invalidRequestInputs
  case invalidResponseVector
  case invalidStopOnPolicy
  case invalidTuple
  case multipleValuesUnsupported
  case notTrusted
  case noDefaultAuthority
  case rejectedForm
  case requestLost
  case requestRejected
  case unsupportedAddressType
  case unsupportedService
  case invalidTupleGroup
  case invalidBaseACLs
  case invalidTupleCredendtials
  case invalidEncoding
  case invalidValidityPeriod
  case invalidRequestor
  case requestDescriptor
  case invalidBundleInfo
  case invalidCRLIndex
  case noFieldValues
  case unsupportedFieldFormat
  case unsupportedIndexInfo
  case unsupportedLocality
  case unsupportedNumAttributes
  case unsupportedNumIndexes
  case unsupportedNumRecordTypes
  case fieldSpecifiedMultiple
  case incompatibleFieldFormat
  case invalidParsingModule
  case databaseLocked
  case datastoreIsOpen
  case missingValue
  case unsupportedQueryLimits
  case unsupportedNumSelectionPreds
  case unsupportedOperator
  case invalidDBLocation
  case invalidAccessRequest
  case invalidIndexInfo
  case invalidNewOwner
  case invalidModifyMode
  case missingRequiredExtension
  case extendedKeyUsageNotCritical
  case timestampMissing
  case timestampInvalid
  case timestampNotTrusted
  case timestampServiceNotAvailable
  case timestampBadAlg
  case timestampBadRequest
  case timestampBadDataFormat
  case timestampTimeNotAvailable
  case timestampUnacceptedPolicy
  case timestampUnacceptedExtension
  case timestampAddInfoNotAvailable
  case timestampSystemFailure
  case signingTimeMissing
  case timestampRejection
  case timestampWaiting
  case timestampRevocationWarning
  case timestampRevocationNotification
  case unexpectedError
}
extension Status : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init(status: Darwin.OSStatus)
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Darwin.OSStatus
  public init?(rawValue: Darwin.OSStatus)
  public var rawValue: Darwin.OSStatus {
    get
  }
}
extension Status : Foundation.CustomNSError {
  public static let errorDomain: Swift.String
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
public class LoginManager {
  public static let `default`: HHDoctorSDK.LoginManager
  public func convert2Model() -> Swift.String?
  public func getUserInfo() -> HHDoctorSDK.HHUserModel?
  public func hasLoginData() -> Swift.Bool
  public func getUserInfo(token: Swift.String, success: ((Swift.String?) -> Swift.Void)? = nil, fail: ((Swift.String) -> Swift.Void)? = nil)
  public func getUserInfoRequest(success: ((Swift.String?) -> Swift.Void)? = nil, fail: ((Swift.String) -> Swift.Void)? = nil)
  public func uuidStr() -> Swift.String?
  @objc deinit
}
public protocol MapContext {
}
final public class Map {
  final public let mappingType: HHDoctorSDK.MappingType
  final public var JSON: [Swift.String : Any] {
    get
    }
  final public var isKeyPresent: Swift.Bool {
    get
    }
  final public var currentValue: Any? {
    get
    }
  final public var currentKey: Swift.String? {
    get
    }
  final public var nestedKeyDelimiter: Swift.String {
    get
    }
  final public var context: HHDoctorSDK.MapContext?
  final public var shouldIncludeNilValues: Swift.Bool
  final public let toObject: Swift.Bool
  public init(mappingType: HHDoctorSDK.MappingType, JSON: [Swift.String : Any], toObject: Swift.Bool = false, context: HHDoctorSDK.MapContext? = nil, shouldIncludeNilValues: Swift.Bool = false)
  final public subscript(key: Swift.String) -> HHDoctorSDK.Map {
    get
  }
  final public subscript(key: Swift.String, delimiter delimiter: Swift.String) -> HHDoctorSDK.Map {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool) -> HHDoctorSDK.Map {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool, delimiter delimiter: Swift.String) -> HHDoctorSDK.Map {
    get
  }
  final public subscript(key: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> HHDoctorSDK.Map {
    get
  }
  final public subscript(key: Swift.String, delimiter delimiter: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> HHDoctorSDK.Map {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool, ignoreNil ignoreNil: Swift.Bool) -> HHDoctorSDK.Map {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool?, delimiter delimiter: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> HHDoctorSDK.Map {
    get
  }
  final public func value<T>() -> T?
  @objc deinit
}
public struct MapError : Swift.Error {
  public var key: Swift.String?
  public var currentValue: Any?
  public var reason: Swift.String?
  public var file: Swift.StaticString?
  public var function: Swift.StaticString?
  public var line: Swift.UInt?
  public init(key: Swift.String?, currentValue: Any?, reason: Swift.String?, file: Swift.StaticString? = nil, function: Swift.StaticString? = nil, line: Swift.UInt? = nil)
}
extension MapError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol BaseMappable {
  mutating func mapping(map: HHDoctorSDK.Map)
}
public protocol Mappable : HHDoctorSDK.BaseMappable {
  init?(map: HHDoctorSDK.Map)
}
public protocol StaticMappable : HHDoctorSDK.BaseMappable {
  static func objectForMapping(map: HHDoctorSDK.Map) -> HHDoctorSDK.BaseMappable?
}
extension BaseMappable {
  public init?(JSONString: Swift.String, context: HHDoctorSDK.MapContext? = nil)
  public init?(JSON: [Swift.String : Any], context: HHDoctorSDK.MapContext? = nil)
  public func toJSON() -> [Swift.String : Any]
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
extension Array where Element : HHDoctorSDK.BaseMappable {
  public init?(JSONString: Swift.String, context: HHDoctorSDK.MapContext? = nil)
  public init(JSONArray: [[Swift.String : Any]], context: HHDoctorSDK.MapContext? = nil)
  public func toJSON() -> [[Swift.String : Any]]
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
extension Set where Element : HHDoctorSDK.BaseMappable {
  public init?(JSONString: Swift.String, context: HHDoctorSDK.MapContext? = nil)
  public init?(JSONArray: [[Swift.String : Any]], context: HHDoctorSDK.MapContext? = nil)
  public func toJSON() -> [[Swift.String : Any]]
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
public enum MappingType {
  case fromJSON
  case toJSON
  public static func == (a: HHDoctorSDK.MappingType, b: HHDoctorSDK.MappingType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
final public class Mapper<N> where N : HHDoctorSDK.BaseMappable {
  final public var context: HHDoctorSDK.MapContext?
  final public var shouldIncludeNilValues: Swift.Bool
  public init(context: HHDoctorSDK.MapContext? = nil, shouldIncludeNilValues: Swift.Bool = false)
  final public func map(JSONObject: Any?, toObject object: N) -> N
  final public func map(JSONString: Swift.String, toObject object: N) -> N
  final public func map(JSON: [Swift.String : Any], toObject object: N) -> N
  final public func map(JSONString: Swift.String) -> N?
  final public func map(JSONObject: Any?) -> N?
  final public func map(JSON: [Swift.String : Any]) -> N?
  final public func mapArray(JSONString: Swift.String) -> [N]?
  final public func mapArray(JSONObject: Any?) -> [N]?
  final public func mapArray(JSONArray: [[Swift.String : Any]]) -> [N]
  final public func mapDictionary(JSONString: Swift.String) -> [Swift.String : N]?
  final public func mapDictionary(JSONObject: Any?) -> [Swift.String : N]?
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]]) -> [Swift.String : N]?
  final public func mapDictionary(JSONObject: Any?, toDictionary dictionary: [Swift.String : N]) -> [Swift.String : N]
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]], toDictionary dictionary: [Swift.String : N]) -> [Swift.String : N]
  final public func mapDictionaryOfArrays(JSONObject: Any?) -> [Swift.String : [N]]?
  final public func mapDictionaryOfArrays(JSON: [Swift.String : [[Swift.String : Any]]]) -> [Swift.String : [N]]?
  final public func mapArrayOfArrays(JSONObject: Any?) -> [[N]]?
  public static func parseJSONStringIntoDictionary(JSONString: Swift.String) -> [Swift.String : Any]?
  public static func parseJSONString(JSONString: Swift.String) -> Any?
  @objc deinit
}
extension Mapper {
  final public func map(JSONfile: Swift.String) -> N?
  final public func mapArray(JSONfile: Swift.String) -> [N]?
}
extension Mapper {
  final public func toJSON(_ object: N) -> [Swift.String : Any]
  final public func toJSONArray(_ array: [N]) -> [[Swift.String : Any]]
  final public func toJSONDictionary(_ dictionary: [Swift.String : N]) -> [Swift.String : [Swift.String : Any]]
  final public func toJSONDictionaryOfArrays(_ dictionary: [Swift.String : [N]]) -> [Swift.String : [[Swift.String : Any]]]
  final public func toJSONString(_ object: N, prettyPrint: Swift.Bool = false) -> Swift.String?
  final public func toJSONString(_ array: [N], prettyPrint: Swift.Bool = false) -> Swift.String?
  public static func toJSONString(_ JSONObject: Any, prettyPrint: Swift.Bool) -> Swift.String?
  public static func toJSONData(_ JSONObject: Any, options: Foundation.JSONSerialization.WritingOptions) -> Foundation.Data?
}
extension Mapper where N : Swift.Hashable {
  final public func mapSet(JSONString: Swift.String) -> Swift.Set<N>?
  final public func mapSet(JSONObject: Any?) -> Swift.Set<N>?
  final public func mapSet(JSONArray: [[Swift.String : Any]]) -> Swift.Set<N>
  final public func toJSONSet(_ set: Swift.Set<N>) -> [[Swift.String : Any]]
  final public func toJSONString(_ set: Swift.Set<N>, prettyPrint: Swift.Bool = false) -> Swift.String?
}
final public class MD5 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension MD5 : HHDoctorSDK.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
public let HHGetUserInfoNotify: Foundation.NSNotification.Name
public protocol MeetingDelegate : ObjectiveC.NSObject {
  func RtsCalling(_ info: HHDoctorSDK.HHInviteDocModel?, channelId: Swift.String)
}
open class NSDecimalNumberTransform : HHDoctorSDK.TransformType {
  public typealias Object = Foundation.NSDecimalNumber
  public typealias JSON = Swift.String
  public init()
  open func transformFromJSON(_ value: Any?) -> Foundation.NSDecimalNumber?
  open func transformToJSON(_ value: Foundation.NSDecimalNumber?) -> Swift.String?
  @objc deinit
}
infix operator <- : DefaultPrecedence
infix operator >>> : DefaultPrecedence
public func <- <T>(left: inout T, right: HHDoctorSDK.Map)
public func >>> <T>(left: T, right: HHDoctorSDK.Map)
public func <- <T>(left: inout T?, right: HHDoctorSDK.Map)
public func >>> <T>(left: T?, right: HHDoctorSDK.Map)
public func <- <T>(left: inout T, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable
public func >>> <T>(left: T, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable
public func <- <T>(left: inout T?, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable
public func >>> <T>(left: T?, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, T>, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, T>, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, T>?, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, T>?, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, [T]>, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, [T]>, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, [T]>?, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, [T]>?, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable
public func <- <T>(left: inout Swift.Array<T>, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable
public func >>> <T>(left: Swift.Array<T>, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable
public func <- <T>(left: inout Swift.Array<T>?, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable
public func >>> <T>(left: Swift.Array<T>?, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable
public func <- <T>(left: inout Swift.Array<Swift.Array<T>>, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable
public func >>> <T>(left: Swift.Array<Swift.Array<T>>, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable
public func <- <T>(left: inout Swift.Array<Swift.Array<T>>?, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable
public func >>> <T>(left: Swift.Array<Swift.Array<T>>?, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable
public func <- <T>(left: inout Swift.Set<T>, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable, T : Swift.Hashable
public func >>> <T>(left: Swift.Set<T>, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable, T : Swift.Hashable
public func <- <T>(left: inout Swift.Set<T>?, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable, T : Swift.Hashable
public func >>> <T>(left: Swift.Set<T>?, right: HHDoctorSDK.Map) where T : HHDoctorSDK.BaseMappable, T : Swift.Hashable
public struct OrderModel : HHDoctorSDK.Mappable {
  public var orderid: Swift.String?
  public var price: Swift.Float?
  public var buyServiceName: Swift.String?
  public var expertId: Swift.String?
  public var expertName: Swift.String?
  public var patientName: Swift.String?
  public init?(map: HHDoctorSDK.Map)
  mutating public func mapping(map: HHDoctorSDK.Map)
}
public protocol PaddingProtocol {
  func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
}
public enum Padding : HHDoctorSDK.PaddingProtocol {
  case noPadding, zeroPadding, pkcs7, pkcs5
  public func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  public func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
  public static func == (a: HHDoctorSDK.Padding, b: HHDoctorSDK.Padding) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension PKCS5 {
  public struct PBKDF1 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: HHDoctorSDK.PKCS5.PBKDF1.Error, b: HHDoctorSDK.PKCS5.PBKDF1.Error) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public enum Variant {
      case md5, sha1
      public static func == (a: HHDoctorSDK.PKCS5.PBKDF1.Variant, b: HHDoctorSDK.PKCS5.PBKDF1.Variant) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, variant: HHDoctorSDK.PKCS5.PBKDF1.Variant = .sha1, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil) throws
    public func calculate() -> Swift.Array<Swift.UInt8>
  }
}
extension PKCS5 {
  public struct PBKDF2 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: HHDoctorSDK.PKCS5.PBKDF2.Error, b: HHDoctorSDK.PKCS5.PBKDF2.Error) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil, variant: HHDoctorSDK.HMAC.Variant = .sha256) throws
    public func calculate() throws -> Swift.Array<Swift.UInt8>
  }
}
@objc public enum PermissionType : Swift.Int {
  case locationAlways
  case locationWhenInUse
  case microphone
  case camera
  case photos
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
extension PermissionType : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public class PhotoPickerConfig {
  public static let `default`: HHDoctorSDK.PhotoPickerConfig
  public var miniPicTip: Swift.Bool
  public var mMaxSelectCount: Swift.Int
  public var mDetailColumnCount: Swift.Int
  @objc deinit
}
public enum PKCS5 {
}
public enum PKCS7 {
}
final public class Poly1305 : HHDoctorSDK.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    public static func == (a: HHDoctorSDK.Poly1305.Error, b: HHDoctorSDK.Poly1305.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static let blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension UIImage {
  public class func gifImageWithData(_ data: Foundation.Data) -> UIKit.UIImage?
  public class func gifImageWithURL(_ gifUrl: Swift.String) -> UIKit.UIImage?
  public class func gifImageWithName(_ name: Swift.String) -> UIKit.UIImage?
}
extension Rabbit {
  convenience public init(key: Swift.String) throws
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
final public class Rabbit {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: HHDoctorSDK.Rabbit.Error, b: HHDoctorSDK.Rabbit.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static let ivSize: Swift.Int
  public static let keySize: Swift.Int
  public static let blockSize: Swift.Int
  final public var keySize: Swift.Int {
    get
  }
  convenience public init(key: Swift.Array<Swift.UInt8>) throws
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>?) throws
  @objc deinit
}
extension Rabbit : HHDoctorSDK.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public protocol RandomAccessCryptor : HHDoctorSDK.Updatable {
  @discardableResult
  mutating func seek(to: Swift.Int) -> Swift.Bool
}
public enum ReachabilityError : Swift.Error {
  case FailedToCreateWithAddress(Darwin.sockaddr_in)
  case FailedToCreateWithHostname(Swift.String)
  case UnableToSetCallback
  case UnableToSetDispatchQueue
}
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
public class Reachability {
  public typealias NetworkReachable = (HHDoctorSDK.Reachability) -> ()
  public typealias NetworkUnreachable = (HHDoctorSDK.Reachability) -> ()
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: HHDoctorSDK.Reachability.NetworkStatus, b: HHDoctorSDK.Reachability.NetworkStatus) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public var whenReachable: HHDoctorSDK.Reachability.NetworkReachable?
  public var whenUnreachable: HHDoctorSDK.Reachability.NetworkUnreachable?
  public var reachableOnWWAN: Swift.Bool
  public var currentReachabilityString: Swift.String {
    get
  }
  public var currentReachabilityStatus: HHDoctorSDK.Reachability.NetworkStatus {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability)
  convenience public init?(hostname: Swift.String)
  convenience public init?()
  @objc deinit
}
extension Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  public var isReachable: Swift.Bool {
    get
  }
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
final public class SHA1 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension SHA1 : HHDoctorSDK.Updatable {
  @discardableResult
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
final public class SHA2 {
  public enum Variant : Swift.RawRepresentable {
    case sha224, sha256, sha384, sha512
    public var digestLength: Swift.Int {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: HHDoctorSDK.SHA2.Variant.RawValue {
      get
    }
    public init?(rawValue: HHDoctorSDK.SHA2.Variant.RawValue)
  }
  public init(variant: HHDoctorSDK.SHA2.Variant)
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension SHA2 : HHDoctorSDK.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
final public class SHA3 {
  final public let blockSize: Swift.Int
  final public let digestLength: Swift.Int
  final public let markByte: Swift.UInt8
  public enum Variant {
    case sha224, sha256, sha384, sha512, keccak224, keccak256, keccak384, keccak512
    public var outputLength: Swift.Int {
      get
    }
    public static func == (a: HHDoctorSDK.SHA3.Variant, b: HHDoctorSDK.SHA3.Variant) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init(variant: HHDoctorSDK.SHA3.Variant)
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension SHA3 : HHDoctorSDK.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
extension String {
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func md5() -> Swift.String
  public func sha1() -> Swift.String
  public func sha224() -> Swift.String
  public func sha256() -> Swift.String
  public func sha384() -> Swift.String
  public func sha512() -> Swift.String
  public func sha3(_ variant: HHDoctorSDK.SHA3.Variant) -> Swift.String
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.String
  public func encrypt(cipher: HHDoctorSDK.Cipher) throws -> Swift.String
  public func encryptToBase64(cipher: HHDoctorSDK.Cipher) throws -> Swift.String?
  public func authenticate<A>(with authenticator: A) throws -> Swift.String where A : HHDoctorSDK.Authenticator
}
extension String {
  public func decryptBase64ToString(cipher: HHDoctorSDK.Cipher) throws -> Swift.String
  public func decryptBase64(cipher: HHDoctorSDK.Cipher) throws -> Swift.Array<Swift.UInt8>
}
extension String {
  public func subFrom(_ index: Swift.Int) -> Swift.String
}
open class TransformOf<ObjectType, JSONType> : HHDoctorSDK.TransformType {
  public typealias Object = ObjectType
  public typealias JSON = JSONType
  public init(fromJSON: @escaping (JSONType?) -> ObjectType?, toJSON: @escaping (ObjectType?) -> JSONType?)
  open func transformFromJSON(_ value: Any?) -> ObjectType?
  open func transformToJSON(_ value: ObjectType?) -> JSONType?
  @objc deinit
}
public func <- <Transform>(left: inout Transform.Object, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType
public func >>> <Transform>(left: Transform.Object, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType
public func <- <Transform>(left: inout Transform.Object?, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType
public func >>> <Transform>(left: Transform.Object?, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType
public func <- <Transform>(left: inout [Transform.Object], right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType
public func >>> <Transform>(left: [Transform.Object], right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType
public func <- <Transform>(left: inout [Transform.Object]?, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType
public func >>> <Transform>(left: [Transform.Object]?, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType
public func <- <Transform>(left: inout [Swift.String : Transform.Object], right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType
public func >>> <Transform>(left: [Swift.String : Transform.Object], right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType
public func <- <Transform>(left: inout [Swift.String : Transform.Object]?, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType
public func >>> <Transform>(left: [Swift.String : Transform.Object]?, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType
public func <- <Transform>(left: inout Transform.Object, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType, Transform.Object : HHDoctorSDK.BaseMappable
public func >>> <Transform>(left: Transform.Object, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType, Transform.Object : HHDoctorSDK.BaseMappable
public func <- <Transform>(left: inout Transform.Object?, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType, Transform.Object : HHDoctorSDK.BaseMappable
public func >>> <Transform>(left: Transform.Object?, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType, Transform.Object : HHDoctorSDK.BaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, Transform.Object>, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType, Transform.Object : HHDoctorSDK.BaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, Transform.Object>, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType, Transform.Object : HHDoctorSDK.BaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, Transform.Object>?, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType, Transform.Object : HHDoctorSDK.BaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, Transform.Object>?, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType, Transform.Object : HHDoctorSDK.BaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, [Transform.Object]>, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType, Transform.Object : HHDoctorSDK.BaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, [Transform.Object]>, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType, Transform.Object : HHDoctorSDK.BaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, [Transform.Object]>?, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType, Transform.Object : HHDoctorSDK.BaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, [Transform.Object]>?, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType, Transform.Object : HHDoctorSDK.BaseMappable
public func <- <Transform>(left: inout Swift.Array<Transform.Object>, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType, Transform.Object : HHDoctorSDK.BaseMappable
public func >>> <Transform>(left: Swift.Array<Transform.Object>, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType, Transform.Object : HHDoctorSDK.BaseMappable
public func <- <Transform>(left: inout Swift.Array<Transform.Object>?, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType, Transform.Object : HHDoctorSDK.BaseMappable
public func >>> <Transform>(left: Swift.Array<Transform.Object>?, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType, Transform.Object : HHDoctorSDK.BaseMappable
public func <- <Transform>(left: inout [[Transform.Object]], right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType
public func >>> <Transform>(left: [[Transform.Object]], right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType
public func <- <Transform>(left: inout [[Transform.Object]]?, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType
public func >>> <Transform>(left: [[Transform.Object]]?, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType
public func <- <Transform>(left: inout Swift.Set<Transform.Object>, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType, Transform.Object : HHDoctorSDK.BaseMappable, Transform.Object : Swift.Hashable
public func >>> <Transform>(left: Swift.Set<Transform.Object>, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType, Transform.Object : HHDoctorSDK.BaseMappable, Transform.Object : Swift.Hashable
public func <- <Transform>(left: inout Swift.Set<Transform.Object>?, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType, Transform.Object : HHDoctorSDK.BaseMappable, Transform.Object : Swift.Hashable
public func >>> <Transform>(left: Swift.Set<Transform.Object>?, right: (HHDoctorSDK.Map, Transform)) where Transform : HHDoctorSDK.TransformType, Transform.Object : HHDoctorSDK.BaseMappable, Transform.Object : Swift.Hashable
public protocol TransformType {
  associatedtype Object
  associatedtype JSON
  func transformFromJSON(_ value: Any?) -> Self.Object?
  func transformToJSON(_ value: Self.Object?) -> Self.JSON?
}
public protocol _UInt8Type {
}
extension UInt8 : HHDoctorSDK._UInt8Type {
}
extension UInt8 {
  public func bits() -> [HHDoctorSDK.Bit]
  public func bits() -> Swift.String
}
public protocol Updatable {
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension Updatable {
  mutating public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  @discardableResult
  mutating public func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @discardableResult
  mutating public func finish() throws -> Swift.Array<Swift.UInt8>
  mutating public func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  mutating public func finish(output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension Updatable {
  @discardableResult
  mutating public func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  mutating public func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  @discardableResult
  mutating public func finish(withBytes bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  mutating public func finish(withBytes bytes: Swift.Array<Swift.UInt8>, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
public typealias onSDKProgress = ((CoreGraphics.CGFloat, Swift.String) -> Swift.Void)
public typealias onSDKUploadOnce = ((Swift.Bool, HHDoctorSDK.SDKUploadModel) -> Swift.Void)
public typealias onSDKFinished = (() -> Swift.Void)
public class SDKUploadConfig {
  public var progress: HHDoctorSDK.onSDKProgress?
  public var uploadOnce: HHDoctorSDK.onSDKUploadOnce?
  public var finished: HHDoctorSDK.onSDKFinished?
  public var orderId: Swift.String?
  public init()
  @objc deinit
}
public class SDKUploadModel {
  public var clouldKey: Swift.String?
  public var filePath: Swift.String? {
    get
    set
  }
  public var smallImage: Swift.String
  public var state: HHDoctorSDK.SDKUploadState?
  public init()
  public init(full: Swift.String?, scale: Swift.String)
  public init(clouldKey: Swift.String?, filePath: Swift.String?, uploadTime: Foundation.TimeInterval?, name: Swift.String?, smallImage: Swift.String)
  @objc deinit
}
public class SDKUploadState {
  public var file: Swift.String?
  public var isSelect: Swift.Bool
  public var changed: (() -> Swift.Void)?
  public var progress: Swift.Float {
    get
    set
  }
  public func isSuccess() -> Swift.Bool
  public func isFail() -> Swift.Bool
  @objc deinit
}
open class URLTransform : HHDoctorSDK.TransformType {
  public typealias Object = Foundation.URL
  public typealias JSON = Swift.String
  public init(shouldEncodeURLString: Swift.Bool = false, allowedCharacterSet: Foundation.CharacterSet = .urlQueryAllowed)
  open func transformFromJSON(_ value: Any?) -> Foundation.URL?
  open func transformToJSON(_ value: Foundation.URL?) -> Swift.String?
  @objc deinit
}
public struct HHGetQuesetionModel : HHDoctorSDK.Mappable {
  public var question: HHDoctorSDK.HHQuesetionModel?
  public var rate: [HHDoctorSDK.rateModel]?
  public init?(map: HHDoctorSDK.Map)
  public init()
  mutating public func mapping(map: HHDoctorSDK.Map)
  public func isHaveQ() -> Swift.Bool
}
public struct HHQuesetionModel : HHDoctorSDK.Mappable {
  public var answerOne: Swift.String?
  public var answerTwo: Swift.String?
  public var content: Swift.String?
  public var id: Swift.Int?
  public init?(map: HHDoctorSDK.Map)
  mutating public func mapping(map: HHDoctorSDK.Map)
}
public struct rateModel : HHDoctorSDK.Mappable {
  public var createTime: Swift.Int?
  public var content: Swift.String?
  public var state: Swift.Int?
  public var id: Swift.Int?
  public var answerOne: Swift.String?
  public init?(map: HHDoctorSDK.Map)
  mutating public func mapping(map: HHDoctorSDK.Map)
}
public class WeakArray<T> {
  public func add(_ delegate: T)
  public func remove(_ delegate: T)
  public func excute(_ block: @escaping ((T?) -> Swift.Void))
  @objc deinit
}
extension HHDoctorSDK.AES.Error : Swift.Equatable {}
extension HHDoctorSDK.AES.Error : Swift.Hashable {}
extension HHDoctorSDK.AES.Variant : Swift.Equatable {}
extension HHDoctorSDK.AES.Variant : Swift.Hashable {}
extension HHDoctorSDK.AES.Variant : Swift.RawRepresentable {}
extension HHDoctorSDK.Bit : Swift.Equatable {}
extension HHDoctorSDK.Bit : Swift.Hashable {}
extension HHDoctorSDK.Bit : Swift.RawRepresentable {}
extension HHDoctorSDK.BlockMode.Error : Swift.Equatable {}
extension HHDoctorSDK.BlockMode.Error : Swift.Hashable {}
extension HHDoctorSDK.Blowfish.Error : Swift.Equatable {}
extension HHDoctorSDK.Blowfish.Error : Swift.Hashable {}
extension HHDoctorSDK.ChaCha20.Error : Swift.Equatable {}
extension HHDoctorSDK.ChaCha20.Error : Swift.Hashable {}
extension HHDoctorSDK.CipherError : Swift.Equatable {}
extension HHDoctorSDK.CipherError : Swift.Hashable {}
extension HHDoctorSDK.CMAC.Error : Swift.Equatable {}
extension HHDoctorSDK.CMAC.Error : Swift.Hashable {}
extension HHDoctorSDK.DGElasticPullToRefreshState : Swift.Equatable {}
extension HHDoctorSDK.DGElasticPullToRefreshState : Swift.Hashable {}
extension HHDoctorSDK.DGElasticPullToRefreshState : Swift.RawRepresentable {}
extension HHDoctorSDK.HHMediaType : Swift.Equatable {}
extension HHDoctorSDK.HHMediaType : Swift.Hashable {}
extension HHDoctorSDK.HHMediaType : Swift.RawRepresentable {}
extension HHDoctorSDK.DateFormat : Swift.Equatable {}
extension HHDoctorSDK.DateFormat : Swift.Hashable {}
extension HHDoctorSDK.DateFormat : Swift.RawRepresentable {}
extension HHDoctorSDK.HHConsType : Swift.Equatable {}
extension HHDoctorSDK.HHConsType : Swift.Hashable {}
extension HHDoctorSDK.HHConsType : Swift.RawRepresentable {}
extension HHDoctorSDK.HHFileCacheManager.HHAssetPathType : Swift.Equatable {}
extension HHDoctorSDK.HHFileCacheManager.HHAssetPathType : Swift.Hashable {}
extension HHDoctorSDK.HHFileCacheManager.HHFileFormat : Swift.Equatable {}
extension HHDoctorSDK.HHFileCacheManager.HHFileFormat : Swift.Hashable {}
extension HHDoctorSDK.HHFileCacheManager.HHFileFormat : Swift.RawRepresentable {}
extension HHDoctorSDK.HHLogMode : Swift.Equatable {}
extension HHDoctorSDK.HHLogMode : Swift.Hashable {}
extension HHDoctorSDK.HHLogMode : Swift.RawRepresentable {}
extension HHDoctorSDK.HHMLoginCode : Swift.Equatable {}
extension HHDoctorSDK.HHMLoginCode : Swift.Hashable {}
extension HHDoctorSDK.HHMLoginCode : Swift.RawRepresentable {}
extension HHDoctorSDK.SkipType : Swift.Equatable {}
extension HHDoctorSDK.SkipType : Swift.Hashable {}
extension HHDoctorSDK.SkipType : Swift.RawRepresentable {}
extension HHDoctorSDK.HHCallType : Swift.Equatable {}
extension HHDoctorSDK.HHCallType : Swift.Hashable {}
extension HHDoctorSDK.HHCallType : Swift.RawRepresentable {}
extension HHDoctorSDK.HHMCallingState : Swift.Equatable {}
extension HHDoctorSDK.HHMCallingState : Swift.Hashable {}
extension HHDoctorSDK.HHMCallingState : Swift.RawRepresentable {}
extension HHDoctorSDK.HHRequestMethod : Swift.Equatable {}
extension HHDoctorSDK.HHRequestMethod : Swift.Hashable {}
extension HHDoctorSDK.HHServerType : Swift.Equatable {}
extension HHDoctorSDK.HHServerType : Swift.Hashable {}
extension HHDoctorSDK.HHPagerViewTransformerType : Swift.Equatable {}
extension HHDoctorSDK.HHPagerViewTransformerType : Swift.Hashable {}
extension HHDoctorSDK.HHPagerViewTransformerType : Swift.RawRepresentable {}
extension HHDoctorSDK.hhToastPosition : Swift.Equatable {}
extension HHDoctorSDK.hhToastPosition : Swift.Hashable {}
extension HHDoctorSDK.HKDF.Error : Swift.Equatable {}
extension HHDoctorSDK.HKDF.Error : Swift.Hashable {}
extension HHDoctorSDK.HMAC.Error : Swift.Equatable {}
extension HHDoctorSDK.HMAC.Error : Swift.Hashable {}
extension HHDoctorSDK.HMAC.Variant : Swift.Equatable {}
extension HHDoctorSDK.HMAC.Variant : Swift.Hashable {}
extension HHDoctorSDK.ItemClass : Swift.Equatable {}
extension HHDoctorSDK.ItemClass : Swift.Hashable {}
extension HHDoctorSDK.ProtocolType : Swift.Equatable {}
extension HHDoctorSDK.ProtocolType : Swift.Hashable {}
extension HHDoctorSDK.AuthenticationType : Swift.Equatable {}
extension HHDoctorSDK.AuthenticationType : Swift.Hashable {}
extension HHDoctorSDK.Accessibility : Swift.Equatable {}
extension HHDoctorSDK.Accessibility : Swift.Hashable {}
extension HHDoctorSDK.Status : Swift.Equatable {}
extension HHDoctorSDK.Status : Swift.Hashable {}
extension HHDoctorSDK.MappingType : Swift.Hashable {}
extension HHDoctorSDK.Padding : Swift.Equatable {}
extension HHDoctorSDK.Padding : Swift.Hashable {}
extension HHDoctorSDK.PKCS5.PBKDF1.Error : Swift.Equatable {}
extension HHDoctorSDK.PKCS5.PBKDF1.Error : Swift.Hashable {}
extension HHDoctorSDK.PKCS5.PBKDF1.Variant : Swift.Equatable {}
extension HHDoctorSDK.PKCS5.PBKDF1.Variant : Swift.Hashable {}
extension HHDoctorSDK.PKCS5.PBKDF2.Error : Swift.Equatable {}
extension HHDoctorSDK.PKCS5.PBKDF2.Error : Swift.Hashable {}
extension HHDoctorSDK.PermissionType : Swift.Hashable {}
extension HHDoctorSDK.PermissionType : Swift.RawRepresentable {}
extension HHDoctorSDK.Poly1305.Error : Swift.Equatable {}
extension HHDoctorSDK.Poly1305.Error : Swift.Hashable {}
extension HHDoctorSDK.Rabbit.Error : Swift.Equatable {}
extension HHDoctorSDK.Rabbit.Error : Swift.Hashable {}
extension HHDoctorSDK.Reachability.NetworkStatus : Swift.Hashable {}
extension HHDoctorSDK.SHA2.Variant : Swift.Equatable {}
extension HHDoctorSDK.SHA2.Variant : Swift.Hashable {}
extension HHDoctorSDK.SHA3.Variant : Swift.Equatable {}
extension HHDoctorSDK.SHA3.Variant : Swift.Hashable {}
